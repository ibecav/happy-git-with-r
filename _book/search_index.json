[["index.html", "Let’s Git After It Let’s Git started License", " Let’s Git After It Originally Jenny Bryan, as modified by Chuck Powell Let’s Git started This book provides opinionated instructions on how to: Install Git and get it working smoothly with GitHub, especially in the RStudio IDE. Develop a few key workflows that cover your most common tasks. Integrate Git and GitHub into your daily work with R and R Markdown. The target reader is someone who uses R for data analysis or who works on R packages, although some of the content may be useful to those working in adjacent areas. This is a CT DPH specific edition, kindly made possible by the original authors’ Creative Commons License. The first two parts, Installation and Connect Git, GitHub, RStudio, provide a “batteries included” quick start to verify your setup. In Early GitHub Wins, we rack up some early success with the basic workflows that are necessary to get your work onto GitHub. We also show the special synergy between R/R Markdown/RStudio and GitHub, which provides a powerful demonstration of why all this setup is worthwhile. Our use of Git/GitHub for DPH work has a slightly different vibe from that of pure software development, due to differences in the user’s context and objective. This book aims to complement existing, general Git resources by highlighting the most rewarding usage patterns for us. This perspective on the Git landscape is presented in Basic Git Concepts and Daily Workflows. License This work, “Let’s Git After It”, is a derivative of “Happy Git and GitHub for the useR” by Jennifer Bryan, used under Creative Commons Attribution-NonCommercial 4.0 International License. “Let’s Git After It” is licensed under Creative Commons Attribution-NonCommercial 4.0 International License. Happy Git and GitHub for the useR by Jennifer Bryan is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. All modifications are also same license. "],["big-picture.html", "Chapter 1 Why Git? Why GitHub? 1.1 Why Git? 1.2 Why GitHub? 1.3 Is it going to hurt? 1.4 What is the payoff? 1.5 Who can do what? 1.6 Special features of GitHub 1.7 What’s special about using R with Git and GitHub?", " Chapter 1 Why Git? Why GitHub? Why do we need hosted version control? 1.1 Why Git? Git is a version control system. Its original purpose was to help groups of developers work collaboratively on big software projects. Git manages the evolution of a set of files – called a repository – in a sane, highly structured way. If you have no idea what I’m talking about, think of it as the “Track Changes” features from Microsoft Word on steroids. Git has been re-purposed by the data science community and many others. In addition to using it for source code, we use it to manage the motley collection of files that make up typical data analytics projects, which often consist of data, figures, reports, and, yes, source code. This book like object benefits from Git. A solo data analyst, working on a single computer, will benefit from adopting version control. But not nearly enough to justify the pain of installation and workflow upheaval. There are much easier ways to get versioned back ups of your files, if that’s all you’re worried about. In my opinion, for new users, the pros of Git only outweigh the cons when you factor in the overhead of communicating and collaborating with other people. Who among us does not need to do that? Your life is much easier if this is baked into your workflow, as opposed to being a separate process that you dread or neglect. 1.2 Why GitHub? This is where hosting services like GitHub come in. They provide a home for our project on the internet. If you have no idea what I’m talking about, think of it as OneDrive but much, much better. The remote host acts as a distribution channel or clearinghouse for our Git-managed project. It allows the whole team to see stuff, sync up , and perhaps even make changes. GitHub has a well-designed web-based interface. Even for private solo projects, it’s a good idea to push your work to a remote location for peace of mind. Why? Because it’s fairly easy to screw up your local Git repository, especially when you’re new at this. The good news is that often only the Git infrastructure is borked up. Your files are just fine! Which makes your Git pickle all the more frustrating. There are official Git solutions to these problems, but they might require expertise and patience you can’t access at 3a.m. If you’ve recently pushed your work to GitHub, it’s easy to grab a fresh copy, patch things up with the changes that only exist locally, and get on with your life. Don’t get too caught up on public versus private at this point. Just get started and figure out how Git/GitHub is going to work for us! 1.3 Is it going to hurt? Yes. You have to install Git, get local Git talking to GitHub, and make sure RStudio can talk to local Git (and, therefore, GitHub). This is one-time or at worst a once-per-computer pain. For new or existing projects, you will: Dedicate a directory (a.k.a “folder”) to it by making it an RStudio Project. This will in turn automagically make it a Git repository. Go about your usual business. But instead of only saving individual files, periodically you make a commit, which takes a multi-file snapshot of the entire project. Have you ever versioned a file by adding your initials or the date? That is effectively a commit, albeit only for a single file: it is a version that is significant to you and that you might want to inspect or revert to later. Push commits to GitHub periodically. This is like sharing a document with colleagues on OneDrive or in Teams or sending it out as an email attachment. It signals you’re ready to make your work visible to others and invite comment or edits. This is a change to your normal, daily workflow. It feels weird at first but quickly becomes second nature. The rest of this site is dedicated to walking you through the necessary setup and working with our Git project(s). 1.4 What is the payoff? Involvement: Even if you never plan on writing a line of code, you can easily get the code we all use from GitHub. If you don’t use Git, you can still browse the project on GitHub like a normal website and even grab everything by downloading a zip archive. If you care deeply about our final project, or just have ideas on ways to make things better you can benefit from GitHub. You can watch the repository to get notified of major activity. You can request features or point out bugs and send them to others. Collaboration: If you need to collaborate on or learn about code development, then you should use Git. Use GitHub as your clearinghouse: individuals work independently, then send work back to GitHub for reconciliation and transmission to the rest of the team. The advantage of Git/GitHub is highlighted by comparing these two ways of collaborating on a document: Edit, save, attach. In this workflow, everyone has one (or more!) copies of the each document and they circulate via email attachment or Team’s chat. Which one is “master”? Is it even possible to say? How do different versions relate to each other? How should versions be reconciled? If you want to see the current best version, how do you get it? All of this usually gets sorted out by social contract and a fairly manual process. Git/GitHub In this workflow, there is only one master copy of the document and it lives in the cloud. Anyone can access the most recent version on demand. Anyone can edit or comment or propose a change and this is immediately available to everyone else. Anyone can see who’s been editing the document and, if disaster strikes, can revert to a previous version. A great deal of ambiguity and annoying reconciliation work has been designed away. 1.5 Who can do what? We have a private repository and it is invisible to the world. Only we can grant read, write (push), or admin access to others. 1.6 Special features of GitHub In addition to a well-designed user interface, GitHub offers two especially important features: Issues. It’s a list of things … bugs, feature requests, to dos, whatever. Issues are tightly integrated with email and therefore allow you to copy/embed important conversations in the associated repo. Issues can be assigned to people (e.g., to dos) and tagged (“bug” or “progress-report”). Issues are tightly integrated with commits and therefore allow you to record that the changes in this commit solve that problem which was discussed in that issue. As a new user of GitHub, one of the most productive things you can do is to use GitHub issues to provide a clear bug report or feature request for our code. Pull requests. Git allows a project to have multiple, independent branches of development, with the notion that some should eventually be merged back into the main development branch. These are technical Git terms but hopefully also make sense on their own. A pull request is a formal proposal that says: “Here are some changes I would like to make.” It might be linked to a specific issue: “Related to #14.” or “Fixes #56”. GitHub facilitates and preserves the discussion of the proposal, holistically and line-by-line. 1.7 What’s special about using R with Git and GitHub? Read about searching within GitHub here. Specific workflows make it rewarding to share source code, rendered reports, and entire projects. Read more about R Markdown, R scripts, and R-heavy projects. Git- and GitHub-related features of the RStudio IDE. This is covered throughout. "],["install-intro.html", "Chapter 2 Installation – Half the battle 2.1 Register an account with GitHub. It’s free! 2.2 Install or upgrade R and RStudio 2.3 Install Git 2.4 Introduce yourself to Git 2.5 Install a Git client", " Chapter 2 Installation – Half the battle Getting all the necessary software installed, configured, and playing nicely together is honestly half the battle when first adopting Git. Brace yourself for some pain. The upside is that you can give yourself a pat on the back once you get through this. And you WILL get through this. If you have some new problem and, especially, the corresponding solution, we’d love to hear from you!. Our installation instructions are brand new, bear with us it’s the hardest part. 2.1 Register an account with GitHub. It’s free! https://github.com Yes this applies to you! Even if you’re the least geeky person in the group and will never ever in a million years write a line of code do this. Registration Advice You change a lot of settings in the future, so don’t fret about any of that now. Except your username. You might want to give that some thought. A few tips, which sadly may contradict each other: Use an email address you actually monitor and follow. The most likely address is your ct.gov address unless you’re already a GitHub user in which case you can stick with that. Incorporate at least part of your actual name! People like to know who they’re dealing with. Also makes your username easier for people to guess or remember. Feel free to reuse your username from other contexts, e.g., Twitter or Slack. You can change your username later, but better to get this right the first time. https://help.github.com/articles/changing-your-github-username/ https://help.github.com/articles/what-happens-when-i-change-my-username/ Go ahead and register your account NOW. If you haven’t already gotten an email invitation from us let Deepti or Chuck know. Since I work is not publicly viewable the invite is clutch. 2.2 Install or upgrade R and RStudio Install a pre-compiled binary of R for your OS from here: https://cloud.r-project.org Already have R installed? Hold on: This is a great time to make sure your R installation is current. Check your current version like so: R.version.string #&gt; [1] &quot;R version 4.0.3 (2020-10-10)&quot; Install RStudio Desktop. Already have RStudio? Hold on: This is a great time to upgrade to the latest version. Download it here: https://www.rstudio.com/products/rstudio/download/ Update your R packages: From RStudio with Packages -&gt; Update or from the console with: ```r update.packages(ask = FALSE, checkBuilt = TRUE) ``` Get current, people. You don’t want to adopt new things on day one. But at some point, running old versions of software adds unnecessary difficulty. Is your R version “old”? R had a major version change in April 2020, with the release of 4.0.0. It is a good idea to be on the current major version, meaning 4 “dot” something at this point, especially if you want to get the most out of your work. Each major version is followed by several years of smaller releases (minor and patch releases). You can be more relaxed about upgrading minor versions, but you still want to stay reasonably current. As the 4.something series unfolds, I advise that you never fall more than 1 minor version behind. As of December 2020 the current version of R is version 4.0.3 (2020-10-10). It’s probably OK if you are still on 4.0.0, but eventually you will start to suffer. In particular, you can no longer install pre-built binary add-on packages from CRAN. Is your RStudio “old”? Unless you have a specific reason to prefer the released version, try the Preview. RStudio is fairly conservative with official releases, so the Preview version is used by many people for their daily work. This allows you to enjoy the latest goodies much sooner. The Preview version updates much more frequently (and in smaller increments) than the released version. This is something you might update once every month or so. 2.3 Install Git You need Git, so RStudio can use it and so you can use it at the command line (maybe). If there’s any chance it’s installed already, verify that, rejoice, and skip this step. Otherwise, find installation instructions below for your operating system. 2.3.1 Git already installed? Go to the shell (Appendix A). Enter which git to request the path to your Git executable: which git #&gt; /usr/bin/git and git --version to see its version: git --version #&gt; git version 2.24.3 (Apple Git-128) If you are successful, that’s great! You have Git already. No need to install! Move on. If, instead, you see something more like git: command not found, keep reading. macOS users might get an immediate offer to install command line developer tools. Yes, you should accept! Click “Install” and read more below. 2.3.2 Windows Install Git for Windows, also known as msysgit or “Git Bash”, to get Git in addition to some other useful tools, such as the Bash shell. Yes, all those names are totally confusing, but you might encounter them elsewhere and I want you to be well-informed. We like this because Git for Windows leaves the Git executable in a conventional location, which will help you and other programs, e.g. RStudio, find it and use it. This also supports a transition to more expert use, because the “Git Bash” shell will be useful as you venture outside of R/RStudio. NOTE: When asked about “Adjusting your PATH environment”, make sure to select “Git from the command line and also from 3rd-party software”. Otherwise, we believe it is good to accept the defaults. Note that RStudio for Windows prefers for Git to be installed below C:/Program Files and this appears to be the default. This implies, for example, that the Git executable on my Windows system is found at C:/Program Files/Git/bin/git.exe. Unless you have specific reasons to otherwise, follow this convention. This also leaves you with a Git client, though not a very good one. So check out Git clients we recommend (chapter 2.5). FYI, this appears to be equivalent to what you would download from here: https://git-scm.com/download/. 2.3.3 macOS Option 1 (highly recommended): Install the Xcode command line tools (not all of Xcode), which includes Git. Go to the shell and enter one of these commands to elicit an offer to install developer command line tools: git --version git config Accept the offer! Click on “Install”. Here’s another way to request this installation, more directly: xcode-select --install We just happen to find this Git-based trigger apropos. Note also that, after upgrading macOS, you might need to re-do the above and/or re-agree to the Xcode license agreement. We have seen this cause the RStudio Git pane to disappear on a system where it was previously working. Use commands like those above to tickle Xcode into prompting you for what it needs, then restart RStudio. Option 2 : If you anticipate getting heavily into scientific computing, you’re going to be installing and updating lots of software. You should check out Homebrew, “the missing package manager for OS X”. Among many other things, it can install Git for you. Once you have Homebrew installed, do this in the shell: brew install git 2.4 Introduce yourself to Git In the shell (Appendix A): git config --global user.name &#39;Jane Doe&#39; git config --global user.email &#39;jane@example.com&#39; git config --global --list substituting your name and the email associated with your GitHub account. The usethis package offers an alternative approach. You can set your Git user name and email from within R: ## install if needed (do this exactly once): ## install.packages(&quot;usethis&quot;) library(usethis) use_git_config(user.name = &quot;Jane Doe&quot;, user.email = &quot;jane@example.org&quot;) More about git config An easy way to get into a shell from RStudio is Tools &gt; Terminal or Tools &gt; Shell. More about the shell in the Appendix A. Special Windows gotchas: If you are struggling on Windows, consider there are different types of shell and you might be in the wrong one. You want to be in a “Git Bash” shell, as opposed to Power Shell or the legacy cmd.exe command prompt. Read more in the Appendix. This might also be a reason to do this configuration via the usethis package in R. What user name should you give to Git? This does not have to be your GitHub user name, although it can be. Another good option is your actual first name and last name. If you commit from different machines, sometimes people work that info into the user name. Your commits will be labelled with this user name, so make it informative to potential collaborators and future you. What email should you give to Git? This must be the email associated with your GitHub account. These commands return nothing. You can check that Git understood what you typed by looking at the output of git config --global --list. Configure the Git editor {#git-editor} Another Git option that many people eventually configure is the editor. At some point, you will fail to give Git what it wants in terms of a commit message and it will kick you into an editor. This can be distressing, if it’s not your editor of choice and you don’t even know how to save and quit. You can enforce your will with something along these lines: git config --global core.editor &quot;emacs&quot; Substitute your preferred editor for \"emacs\" here. Software Carpentry’s Git lesson has a comprehensive listing of the exact git config command needed for many combinations of OS and editor. 2.5 Install a Git client This is optional. Learning to use version control can be rough at first. I found the use of a GUI – as opposed to the command line – extremely helpful when I was getting started. I call this sort of helper application a Git client. It’s really a Git(Hub) client because it also helps you interact with GitHub or other remotes. 2.5.1 What is a Git client? Why would you want one? “Git” is really just a collection of individual commands you execute in the shell (Appendix A). This interface is not appealing for everyone. Some may prefer to do Git operations via a client with a graphical interface. Git and your Git client are not the same thing, just like R and RStudio are not the same thing. A Git client and an integrated development environment, such as RStudio, are not necessary to use Git or R, respectively. But they make the experience more pleasant because they reduce the amount of command line bullshittery and provide a richer visual representation of the current state. RStudio offers a very basic Git client via its Git pane. I use this often for simple operations, but you probably want another, more powerful one as well. Fair warning: for some tasks, you must use the command line. But the more powerful your Git client is, the less often this happens. The visual overview given by your Git client can also be invaluable for understanding the current state of things, even when preparing calls to command line Git. Fantastic news: because all of the clients are just forming and executing Git commands on your behalf, you don’t have to pick one. You can literally do one operation from the command line, do another from RStudio, and it just works. Very rarely, both clients will scan the repo at the same time and you’ll get an error message about .git/index.lock. Try the operation again at least once before doing any further troubleshooting. 2.5.2 No one is giving out Git Nerd merit badges Work with Git in whatever way makes you most effective. Feel free to revisit your approach over time or to use different approaches for different tasks. No one can tell whether you use the command line or a GUI when they look at your Git history or your GitHub repo. I sometimes encounter people who feel it’s “better” to use command line Git, but for very ill-defined reasons. These people may feel like they should work in the shell, even if it leads to Git-avoidance, frequent mistakes, or limiting themselves to a small set of ~3 Git commands. This is counterproductive. I had two false starts with Git, where I failed to get proficient enough, quickly enough to truly incorporate version control into my daily work. I found a visual Git client invaluable – SourceTree, in my case. It made me willing to use Git multiple times per day, for a sustained period of time. This helped me build the mental model necessary for more advanced Git operations like rebasing, cherry-picking, and resetting. If your Git life happens on your own computer, there is no reason to deny yourself a GUI if that’s what you like. If you prefer working in the shell or if you frequently log into a remote server, then it makes sense to prioritize building Git skills at the command line. Do whatever works for you, but don’t do anything for the sake of purity or heroism. 2.5.3 Recommended Git clients GitKraken is a free, powerful Git(Hub) client that is my current favorite. It’s especially exciting because it works on Windows, macOS, and Linux. This is great news, especially for long-suffering Linux users who have previously had very few options. It also has a great tutorial https://youtu.be/ub9GfRziCtU GitHub offers a free Git(Hub) client, GitHub Desktop, for Windows and macOS. Although we previously discouraged its use, GitHub’s client has since gotten a thorough makeover that eliminates several of our concerns, so we’re cautiously optimistic. GitHub Desktop is aimed at beginners who want the most useful features of Git front and center. The flipside is that it may not support some of the more advanced workflows exposed by the clients above. If you choose GitHub Desktop and it works well for you, we’d love to hear more in an issue, so we can continue to refine this recommendation. "],["connect-intro.html", "Chapter 3 Connecting – Can you hear me now? 3.1 Connect to GitHub 3.2 Connect RStudio to Git and GitHub 3.3 Detect Git from RStudio", " Chapter 3 Connecting – Can you hear me now? Next we’ll walk through some basic operations to confirm you have installed the necessary software and that the necessary connections are being made, between tools on your computer and between your computer and GitHub. We use Git in the shell to make sure you can clone a repo from GitHub and establish two-way communications. We confirm that RStudio can work with your Git installation to perform local operations and communicate with GitHub. We present two approaches for persistently authenticating yourself with GitHub, so you don’t need to provide credentials ad nauseam. Hopefully you won’t need it, but this part concludes with two troubleshooting chapters: Detect Git from RStudio and RStudio, Git, GitHub Hell. 3.1 Connect to GitHub Objective: make sure that you can pull from and push to GitHub from your computer. I do not explain all the shell (Appendix A) and Git commands in detail. This is a black box diagnostic / configuration exercise. In later chapters, we revisit these operations with much more narrative. 3.1.1 Make a repo on GitHub Go to https://github.com and make sure you are logged in. Click green “New repository” button. Or, if you are on your own profile page, click on “Repositories”, then click the green “New” button. How to fill this in: Repository name: myrepo (or whatever you wish, we’ll delete this soon anyway). Description: “testing my setup” (or whatever, but some text is good for the README). Public. YES Initialize this repository with a README. For everything else, just accept the default. Click big green button “Create repository.” Copy the HTTPS clone URL to your clipboard via the green “Clone or Download” button. 3.1.2 Clone the repo to your local computer Go to the shell (Appendix A). Take charge of – or at least notice! – what directory you’re in. pwd displays the working directory. cd is the command to change directory. Personally, I would do this sort of thing in ~/tmp. Clone myrepo from GitHub to your computer. This URL should have your GitHub username and the name of your practice repo. If your shell (Appendix A) cooperates, you should be able to paste the whole https://.... bit that we copied above. But some shells are not (immediately) clipboard aware. In that sad case, you must type it. Accurately. git clone https://github.com/YOUR-USERNAME/YOUR-REPOSITORY.git This should look something like this: jenny@2015-mbp tmp $ git clone https://github.com/jennybc/myrepo.git Cloning into &#39;myrepo&#39;... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. Checking connectivity... done. Make this new repo your working directory, list its files, display the README, and get some information on its connection to GitHub: cd myrepo ls head README.md git remote show origin This should look something like this: jenny@2015-mbp ~ $ cd myrepo jenny@2015-mbp myrepo $ ls README.md jenny@2015-mbp myrepo $ head README.md # myrepo tutorial development jenny@2015-mbp myrepo $ git remote show origin * remote origin Fetch URL: https://github.com/jennybc/myrepo.git Push URL: https://github.com/jennybc/myrepo.git HEAD branch: master Remote branch: master tracked Local branch configured for &#39;git pull&#39;: master merges with remote master Local ref configured for &#39;git push&#39;: master pushes to master (up to date) 3.1.3 Make a local change, commit, and push Add a line to README and verify that Git notices the change: echo &quot;A line I wrote on my local computer&quot; &gt;&gt; README.md git status This should look something like this: jenny@2015-mbp myrepo $ echo &quot;A line I wrote on my local computer&quot; &gt;&gt; README.md jenny@2015-mbp myrepo $ git status On branch master Your branch is up-to-date with &#39;origin/master&#39;. Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: README.md no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Stage (“add”) and commit this change and push to your remote repo on GitHub. If you’re a new GitHub user, you will be challenged for your GitHub username and password. Provide them! git add -A git commit -m &quot;A commit from my local computer&quot; git push The -m \"blah blah blah\" piece is very important! Git requires a commit message for every commit, so if you forget the -m flag, Git will prompt you for a commit message anyway. And you might not like the editor that Git chooses. It is good practice to write meaningful commit messages, so that, in the future, potential collaborators (and your future self) will understand the progression of a project. This should look something like this: jenny@2015-mbp myrepo $ git add -A jenny@2015-mbp myrepo $ git commit -m &quot;A commit from my local computer&quot; [master de669ba] A commit from my local computer 1 file changed, 1 insertion(+) jenny@2015-mbp myrepo $ git push Counting objects: 3, done. Delta compression using up to 8 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 311 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) To https://github.com/jennybc/myrepo.git b4112c5..de669ba master -&gt; master 3.1.4 Windows and line endings On Windows, you might see a message about LF will be replaced by CRLF. This is normal and does not require any action on your part. Windows handles line endings differently from other operating systems, but the default setup for Git for Windows is appropriate for most people and situations. Here’s a command to reveal the current line ending configuration and some typical output on Windows: $ git config --show-origin --get core.autocrlf file:&quot;C:\\\\ProgramData/Git/config&quot; true If your value shows as false, you can set it to true with this command: $ git config --global core.autocrlf true true is the current default setting for core.autocrlf for Git for Windows, our recommended method for installing Git on Windows. The need to set this explicitly in your global user config suggests you should consider reinstalling or updating Git for Windows. 3.1.5 Confirm the local change propagated to the GitHub remote Go back to the browser. I assume we’re still viewing your new GitHub repo. Refresh. You should see the new “A line I wrote on my local computer” in the README. If you click on “commits,” you should see one with the message “A commit from my local computer.” If you have made it this far, you are ready to graduate to using Git and GitHub with RStudio (chapter 3.2). But first … 3.1.6 Am I really going to type GitHub username and password on each push? It is likely that your first push, above, leads to a challenge for your GitHub username and password. This will drive you crazy in the long-run and make you reluctant to push. You want to eliminate this annoyance. Luckily, if you’ve installed Git one of the ways recommended by Happy Git, it is likely that Git is already using a credential helper provided by your operating system! If so, your GitHub credentials were cached when you successfully pushed above. This setup applies across repos, i.e. it’s not limited to our current test repo. I suggest you make another local change to README.md, stage (i.e. “add”) it, commit it, and push, using the commands shown above. If this “just works” and shows up on GitHub, rejoice. You are ready to work with GitHub via HTTPS without constantly re-entering your credentials. You are ready to delete this toy repo. If you are challenged for your username and password again, cache credentials for HTTPS access, chapter D. Now is the perfect time to do this, since you have a functioning test repo. 3.1.7 Clean up Local When you’re ready to clean up, you can delete the local repo any way you like. It’s just a regular directory on your computer. Here’s how to do that in the shell, if current working directory is myrepo: cd .. rm -rf myrepo/ GitHub In the browser, go to your repo’s landing page on GitHub. Click on “Settings”. Scroll down, click on “delete repository,” and do as it asks. 3.2 Connect RStudio to Git and GitHub Here we verify that RStudio can issue Git commands on your behalf. Assuming that you’ve gotten local Git to talk to GitHub, this means you’ll also be able to pull from and push to GitHub from RStudio. In later chapters and in live workshops, we revisit these operations with much more explanation. If you succeed here, your set up is DONE. 3.2.1 Prerequisites We assume the following: You’ve registered a free GitHub account (chapter 2.1). You’ve installed/updated R and RStudio (chapter 2.2). You’ve installed Git (chapter 2.3). You’ve introduced yourself to Git (chapter 2.4). You’ve confirmed that you can push to / pull from GitHub from the command line (chapter 3.1). 3.2.2 Make a repo on GitHub Go to https://github.com and make sure you are logged in. Click the green “New repository” button. Or, if you are on your own profile page, click on “Repositories”, then click the green “New” button. How to fill this in: Repository name: myrepo (or whatever you wish, we’ll delete this soon anyway). Description: “testing my setup” (or whatever, but some text is good for the README). Public. YES Initialize this repository with a README. For everything else, just accept the default. Click the big green button “Create repository.” Copy the HTTPS clone URL to your clipboard via the green “Clone or Download” button. 3.2.3 Clone the new GitHub repository to your computer via RStudio In RStudio, start a new Project: File &gt; New Project &gt; Version Control &gt; Git. In “Repository URL”, paste the URL of your new GitHub repository. It will be something like this https://github.com/jennybc/myrepo.git. Do you NOT see an option to get the Project from Version Control? Restart RStudio and try again. Still no luck? Go to chapter 3.3 for tips on how to help RStudio find Git. Accept the default project directory name, e.g. myrepo, which coincides with the GitHub repo name. Take charge of – or at least notice! – where the Project will be saved locally. A common rookie mistake is to have no idea where you are saving files or what your working directory is. Pay attention. Be intentional. Personally, I would do this in ~/tmp. I suggest you check “Open in new session”, as that’s what you’ll usually do in real life. Click “Create Project”. You should find yourself in a new local RStudio Project that represents the new test repo we just created on GitHub. This should download the README.md file from GitHub. Look in RStudio’s file browser pane for the README.md file. 3.2.4 Make local changes, save, commit From RStudio, modify the README.md file, e.g., by adding the line “This is a line from RStudio”. Save your changes. Commit these changes to your local repo. How? From RStudio: Click the “Git” tab in upper right pane. Check “Staged” box for README.md. If you’re not already in the Git pop-up, click “Commit”. Type a message in “Commit message”, such as “Commit from RStudio”. Click “Commit”. 3.2.5 Push your local changes online to GitHub Click the green “Push” button to send your local changes to GitHub. If you are challenged for username and password, provide them (but see below). You should see some message along these lines. [master dc671f0] blah 3 files changed, 22 insertions(+) create mode 100644 .gitignore create mode 100644 myrepo.Rproj 3.2.6 Confirm the local change propagated to the GitHub remote Go back to the browser. I assume we’re still viewing your new GitHub repo. Refresh. You should see the new “This is a line from RStudio” in the README. If you click on “commits”, you should see one with the message “Commit from RStudio”. If you have made it this far, you are DONE with set up. But first … 3.2.7 Were you challenged for GitHub username and password? If you somehow haven’t done so yet, now is the perfect time to make sure you don’t need to keep providing username and password on each push. First, make another small change locally and push again, to make sure we’ve given your system every opportunity to cache your credentials and retrieve them from the cache. It might “just work”. Are you still challenged? Credential caching for HTTPS access, chapter D. Now is the perfect time to do this, since you have a functioning test repo. 3.2.8 Clean up Local When you’re ready to clean up, you can delete the local repo any way you like. It’s just a regular directory on your computer. GitHub In the browser, go to your repo’s landing page on GitHub. Click on “Settings”. Scroll down, click on “delete repository,” and do as it asks. 3.3 Detect Git from RStudio If you want RStudio to help with your Git and GitHub work, it must be able to find the Git executable. This usually “just works”, so this page is aimed at people who have reason to suspect they have a problem. This is something you set up once-per-computer. 3.3.1 Do you have a problem? Let’s check if RStudio can find the Git executable. File &gt; New Project… Do you see an option to create from Version Control? If yes, good. Select New Directory &gt; Empty Project. Do you see a checkbox “Create a git repository”? If yes, good, CHECK IT. Give this disposable test project a name and click Create Project. Do you see a “Git” tab in the upper right pane, the same one that has “Environment” and “History”? If yes, good. If all looks good, you can delete this project. Looks like RStudio and Git are talking to each other. Keep reading if things don’t go so well or you want to know more. 3.3.2 Find Git yourself RStudio can only act as a GUI front-end for Git if Git has been successfully installed (chapter 2.3) AND RStudio can find it. A basic test for successful installation of Git is to simply enter git in the shell (Appendix A). If you get a complaint about Git not being found, it means installation was unsuccessful or that it is not being found, i.e. it is not on your PATH. If you are not sure where the Git executable lives, try this in a shell: which git (Mac, Linux, Git Bash shell on Windows) where git (Windows command prompt, i.e. cmd.exe) 3.3.3 Tell RStudio where to find Git If Git appears to be installed and findable, launch RStudio. Quit and re-launch RStudio if there’s any doubt in your mind about whether you opened RStudio before or after installing Git. Don’t make me stop this car and restart RStudio for you in office hours. DO IT. From RStudio, go to Tools &gt; Global Options &gt; Git/SVN and make sure that the box Git executable points to your Git executable. On macOS and Linux, the path usually looks something like this: /usr/bin/git If you need to set this on macOS, it can sometimes be hard to navigate to the necessary directory, once you’ve clicked “Browse” and are working with a Finder-type window. The keyboard shortcut “command + shift + g” will summon “Go To Folder”, where you will be able to type or paste any path you want. On Windows, this path should look something like this: C:/Program Files/Git/bin/git.exe and here is a screenshot on Windows: RStudio screenshot showing path to Git executable WARNING: On Windows, do NOT use C:/Program Files/Git/cmd/git.exe. bin in the path is GOOD YES! cmd in the path is BAD NO! WARNING: On Windows, do NOT set this to git-bash.exe. Something that ends in git.exe is GOOD YES! git-bash.exe is BAD NO! Restart RStudio if you make any changes. Don’t make me stop this car again and restart RStudio for you in office hours. DO IT. Do the steps at the top of the page to see if RStudio and Git are communicating now. No joy? I’ve seen this help: With your Project open, go to Tools &gt; Project Options.... If available, click on “Git/SVN” and select “Git” in the Version control system dropdown menu. Answer “yes” to the “Confirm New Git Repository” pop up. Answer “yes” to the “Confirm Restart RStudio” pop up. If you installed Git via GitHub for Windows, it is possible the Git executable is really well hidden. Get help or use one of our recommended methods of installing Git. Your PATH is probably not set up correctly and/or you should re-install Git and control/notice where it’s going. Read more in C. Get our help. "],["usage-intro.html", "Chapter 4 Get started with GitHub 4.1 New project, GitHub first 4.2 Existing project, GitHub first 4.3 Existing project, GitHub last 4.4 Test drive R Markdown 4.5 Render an R script", " Chapter 4 Get started with GitHub Now that we’ve verified your Git/GitHub/RStudio setup, we can demo the workflows you’ll use to get your work onto GitHub: New project, GitHub first is the easiest way to get a working project. Existing project, GitHub first is a deeply pragmatic way to get pre-existing work onto GitHub. Existing project, GitHub last is the more proper way to connect existing local work to a remote on GitHub, especially if there’s already a Git history. This part concludes with two R-specific workflows that show off how well R Markdown (the format) and rmarkdown (the package) work with GitHub: Test drive R Markdown Render an R script 4.1 New project, GitHub first We create a new Project, with the preferred “GitHub first, then RStudio” sequence. Why do we prefer this? Because this method of copying the Project from GitHub to your computer also sets up the local Git repository for immediate pulling and pushing. Under the hood, we are doing git clone. You’ve actually done this before during set up (chapter 3.2). We’re doing it again, with feeling. The workflow is pretty similar for other repository managers like GitLab or Bitbucket. We will specify below when you may need to do something differently. 4.1.1 Make a repo on GitHub Do this once per new project. Go to https://github.com and make sure you are logged in. Click green “New repository” button. Or, if you are on your own profile page, click on “Repositories”, then click the green “New” button. Repository name: myrepo (or whatever you wish) Public YES Initialize this repository with a README Click the big green button “Create repository.” Copy the HTTPS clone URL to your clipboard via the green “Clone or Download” button. Or copy the SSH URL if you chose to set up SSH keys. 4.1.2 New RStudio Project via git clone In RStudio, start a new Project: File &gt; New Project &gt; Version Control &gt; Git. In the “repository URL” paste the URL of your new GitHub repository. It will be something like this https://github.com/jennybc/myrepo.git. Be intentional about where you create this Project. Suggest you “Open in new session”. Click “Create Project” to create a new directory, which will be all of these things: a directory or “folder” on your computer a Git repository, linked to a remote GitHub repository an RStudio Project In the absence of other constraints, I suggest that all of your R projects have exactly this set-up. This should download the README.md file that we created on GitHub in the previous step. Look in RStudio’s file browser pane for the README.md file. There’s a big advantage to the “GitHub first, then RStudio” workflow: the remote GitHub repo is added as a remote for your local repo and your local master branch is now tracking master on GitHub. This is a technical but important point about Git. The practical implication is that you are now set up to push and pull. No need to fanny around setting up Git remotes and tracking branches on the command line. 4.1.2.1 Optional: peek under the hood Completely optional activity: use command line Git to see what we’re talking about above, i.e. the remote and tracking branch setup. git remote -vor git remote --verbose shows the remotes you have setup. Here’s how that looks for someone using SSH with GitHub and calling it origin (a convention I hate but am resigned to): $ git remote -v origin git@github.com:jennybc/myrepo.git (fetch) origin git@github.com:jennybc/myrepo.git (push) git branch -vv prints info about the current branch. In particular, we can see that local master is tracking the master branch on origin, a.k.a. origin/master. $ git branch -vv * master 7c98308 [origin/master] Initial commit git clone, which RStudio did for us, sets all of this up automatically. This is why “GitHub first, then RStudio” is the preferred way to start projects early in your Git/GitHub life. 4.1.3 Make local changes, save, commit Do this every time you finish a valuable chunk of work, probably many times a day. From RStudio, modify the README.md file, e.g., by adding the line “This is a line from RStudio”. Save your changes. Commit these changes to your local repo. How? Click the “Git” tab in upper right pane Check “Staged” box for any files whose existence or modifications you want to commit. To see more detail on what’s changed in file since the last commit, click on “Diff” for a Git pop-up If you’re not already in the Git pop-up, click “Commit” Type a message in “Commit message”, such as “Commit from RStudio”. Click “Commit” 4.1.4 Push your local changes to GitHub Do this a few times a day, but possibly less often than you commit. You have new work in your local Git repository, but the changes are not online yet. This will seem counterintuitive, but first let’s stop and pull from GitHub. Why? Establish this habit for the future! If you make changes to the repo in the browser or from another machine or (one day) a collaborator has pushed, you will be happier if you pull those changes in before you attempt to push. Click the blue “Pull” button in the “Git” tab in RStudio. I doubt anything will happen, i.e. you’ll get the message “Already up-to-date.” This is just to establish a habit. Click the green “Push” button to send your local changes to GitHub. You should see some message along these lines. [master dc671f0] blah 3 files changed, 22 insertions(+) create mode 100644 .gitignore create mode 100644 myrepo.Rproj 4.1.5 Confirm the local change propagated to the GitHub remote Go back to the browser. I assume we’re still viewing your new GitHub repo. Refresh. You should see the new “This is a line from RStudio” in the README. If you click on “commits,” you should see one with the message “Commit from RStudio”. 4.1.6 Make a change on GitHub Click on README.md in the file listing on GitHub. In the upper right corner, click on the pencil for “Edit this file”. Add a line to this file, such as “Line added from GitHub.” Edit the commit message in “Commit changes” or accept the default. Click the big green button “Commit changes.” 4.1.7 Pull from GitHub Back in RStudio locally … Inspect your README.md. It should NOT have the line “Line added from GitHub”. It should be as you left it. Verify that. Click the blue Pull button. Look at README.md again. You should now see the new line there. 4.1.8 The end Now just … repeat. Do work somewhere. Commit it. Push it or pull it* depending on where you did it, but get local and remote “synced up”. Repeat. * Note that in general (and especially in future when collaborating with other developers) you will usually need to pull changes from the remote (GitHub) before pushing the local changes you have made. For this reason, it’s a good idea to try and get into the habit of pulling before you attempt to push. 4.2 Existing project, GitHub first A novice-friendly workflow for bringing an existing R project into the RStudio and Git/GitHub universe. We do this in a slightly awkward way, in order to avoid using Git at the command line. You won’t want to work this way forever, but it’s perfectly fine as you’re getting started! We assume you’ve got your existing R project isolated in a directory on your computer. If that’s not already true, make it so. Create a directory and marshal all the existing data and R scripts there. It doesn’t really matter where you do this, but note where the project currently lives. 4.2.1 Make a repo on GitHub Go to https://github.com and make sure you are logged in. Click the green “New repository” button. Or, if you are on your own profile page, click on “Repositories”, then click the green “New” button. Pick a repository name that actually reminds you what the project is about! But try to be concise. Public YES Initialize this repository with a README Click the big green button “Create repository.” Copy the HTTPS clone URL to your clipboard via the green “Clone or Download” button. Or copy the SSH URL if you chose to set up SSH keys. 4.2.2 New RStudio Project via git clone In RStudio, start a new Project: File &gt; New Project &gt; Version Control &gt; Git. In the “repository URL” paste the URL of your new GitHub repository. It will be something like this https://github.com/jennybc/myrepo.git. Be intentional about where you create this Project. Suggest you “Open in new session”. Click “Create Project” to create a new directory, which will be all of these things: a directory or “folder” on your computer a Git repository, linked to a remote GitHub repository an RStudio Project This should download the README.md file that we created on GitHub in the previous step. Look in RStudio’s file browser pane for the README.md file. 4.2.3 Bring your existing project over Using your favorite method of moving or copying files, copy the files that constitute your existing project into the directory for this new project. In RStudio, consult the Git pane and the file browser. Are you seeing all the files? They should be here if your move/copy was successful. Are they showing up in the Git pane with questions marks? They should be appearing as new untracked files. 4.2.4 Stage and commit Commit your files to this repo. How? Click the “Git” tab in upper right pane Check “Staged” box for all files you want to commit. Default: stage it. When to reconsider: this will all go to GitHub. So do consider if that is appropriate for each file. You can absolutely keep a file locally, without committing it to the Git repo and sending to GitHub. Just let it sit there in your Git pane, without being staged. No harm will be done. If this is a long-term situation, list the file in .gitignore. If you’re not already in the Git pop-up, click “Commit” Type a message in “Commit message”, such as “init”. Click “Commit” 4.2.5 Push your local changes to GitHub Click the green “Push” button to send your local changes to GitHub. You should see some message along these lines. [master dc671f0] blah 3 files changed, 22 insertions(+) create mode 100644 .gitignore create mode 100644 myrepo.Rproj 4.2.6 Confirm the local change propagated to the GitHub remote Go back to the browser. I assume we’re still viewing your new GitHub repo. Refresh. You should see all the project files you committed there. If you click on “commits,” you should see one with the message “init”. 4.2.7 The end Now just … repeat. Do work somewhere. Commit it. Push it or pull it* depending on where you did it, but get local and remote “synced up”. Repeat. * Note that in general (and especially in future when collaborating with other developers) you will usually need to pull changes from the remote (GitHub) before pushing the local changes you have made. For this reason, it’s a good idea to try and get into the habit of pulling before you attempt to push. 4.3 Existing project, GitHub last An explicit workflow for connecting an existing local R project to GitHub, when for some reason you cannot or don’t want to do a “GitHub first” workflow (see chapters 4.1 and 4.2). When does this come up? Example: it’s an existing project that is already a Git repo with a history you care about. Then you have to do this properly. This is less desirable for a novice because there are more opportunities to get confused and make a mistake. RStudio and the usethis package are gradually making this easier, so you can avoid working with Git in the shell (Appendix A). But command line Git remains a viable option. All are covered below. 4.3.1 Make or verify an RStudio Project We assume you’ve got your existing R project isolated in a directory on your computer. If it’s not already an RStudio Project, make it so: If you use the usethis package, set the existing directory as the current project with usethis::create_project(). Within RStudio you can do: File &gt; New Project &gt; Existing Directory and, if you wish, “Open in new session”. If your project is already an RStudio Project, launch it. 4.3.2 Make or verify a Git repo You should be in RStudio now, in your project. Is it already a Git repository? The presence of the Git pane should tip you off. If yes, you’re done. If not, you have several options: If you have the usethis package, call usethis::use_git(). In RStudio, go to Tools &gt; Project Options … &gt; Git/SVN. Under “Version control system”, select “Git”. Confirm New Git Repository? Yes! In the shell, in Project’s directory, do git init. If you used RStudio or usethis, the Project should re-launch in RStudio. Do that yourself if you did git init. RStudio should now have a Git pane. 4.3.3 Stage and commit If your local project was already a Git repo and was up-to-date, move on. Otherwise, you probably need to stage and commit. Click the “Git” tab in upper right pane Check “Staged” box for all files you want to commit. Default: stage everything When to do otherwise: this will all go to GitHub. So consider if that is appropriate for each file. You can absolutely keep a file locally, without committing it to the Git repo and sending to GitHub. Just let it sit there in your Git pane, without being staged. No harm will be done. If this is a long-term situation, list the file in .gitignore. If you’re not already in the Git pop-up, click “Commit” Type a message in “Commit message”. Click “Commit” 4.3.4 Make and connect a GitHub repo, option 1 If you use the usethis package AND you have configured a GitHub Personal Access Token (PAT) (see the appendix for how to set this up.), do this in R: usethis::use_github() This will create a new repo on GitHub, add it as a remote, set up a tracking branch, and open it in your browser. Read the use_github() help to learn about its arguments and advice on configuring a PAT. This is extremely handy for a variety of workflows that call the GitHub API. Consider setting this up if you use usethis, devtools, or gh regularly. 4.3.5 Make and connect a GitHub repo, option 2 4.3.5.1 Make a new repo on GitHub Go to https://github.com and make sure you are logged in. Click the green “New repository” button. Or, if you are on your own profile page, click on “Repositories”, then click the green “New” button. Pick a repository name – it should probably match the name of your local Project and directory. Why confuse yourself? Public or private, as appropriate DO NOT initialize this repository with a README. Click the big green button “Create repository.” Copy the HTTPS clone URL to your clipboard via the green “Clone or Download” button. Or copy the SSH URL if you chose to set up SSH keys. 4.3.5.2 Connect local repo to GitHub repo You can do this in the shell or, with recent versions of RStudio, via RStudio. 4.3.5.3 In RStudio Click on the “two purple boxes and a white square” in the Git pane. Click “Add remote”. Paste the URL here and pick a remote name, almost certainly origin. Now “Add”. We should be back in the “New Branch” dialog (if not, click on the “two purple boxes and a white square” in the Git pane again). I assume you’re on the master branch want it to track master on GitHub. Enter master as the branch name and make sure “Sync branch with remote” is checked. Click “Create” (yes, even though the branch already exists). In the next dialog, choose “overwrite”. 4.3.5.4 In the shell In a shell, do this, substituting your URL: git remote add origin https://github.com/jennybc/myrepo.git Push and cement the tracking relationship between your local master branch and master on GitHub: git push --set-upstream origin master 4.3.6 Confirm the local files propagated to the GitHub remote Go back to the browser. I assume we’re still viewing your new GitHub repo. Refresh. You should see all the project files you committed there. If this project already had a Git history, it should be reflected on GitHub. 4.3.7 The end Now just … repeat. Do work somewhere. Commit it. Push it or pull it depending on where you did it, but get local and remote “synced up”. Repeat. Note that in general (and especially in future when collaborating with other developers) you will usually need to pull changes from the remote (GitHub) before pushing the local changes you have made. For this reason, it’s a good idea to try and get into the habit of pulling before you attempt to push. 4.4 Test drive R Markdown We will author an R Markdown document and render it to HTML. We discuss how to keep the intermediate Markdown file, the figures, and what to commit to Git and push to GitHub. If GitHub is the primary venue, we render directly to GitHub-flavored markdown and never create HTML. Here is the official R Markdown documentation: http://rmarkdown.rstudio.com 4.4.1 Hello World We’ll practice with RStudio’s boilerplate R Markdown document. Launch RStudio in a Project that is a Git repo that is connected to a GitHub repo. We are modelling “walk before you run” here. It is best to increase complexity in small increments. We test our system’s ability to render the “hello world” of R Markdown documents before we muddy the waters with our own, probably buggy, documents. Do this: File &gt; New File &gt; R Markdown … Give it an informative title. This will appear in the document but does not necessarily have anything to do with the file’s name. But the title and filename should be related! Why confuse yourself? The title is for human eyeballs, so it can contain spaces and punctuation. The filename is for humans and computers, so it should have similar words in it but no spaces and no punctuation. Accept the default Author or edit if you wish. Accept the default output format of HTML. Click OK. Save this document to a reasonable filename and location. The filename should end in .Rmd or .rmd. Save in the top-level of this RStudio project and Git repository, that is also current working directory. Trust me on this and do this for a while. You might want to commit here. So you can see what’s about to change … Click on “Knit HTML” or do File &gt; Knit Document. RStudio should display a preview of the resulting HTML. Also look at the file browser. You should see the R Markdown document, i.e. foo.Rmd AND the resulting HTML foo.html. Congratulations, you’ve just made your first reproducible report with R Markdown. You might want to commit here. 4.4.2 Push to GitHub Push the current state to GitHub. Go visit it in the browser. Do you see the new files? An R Markdown document and the associated HTML? Visit both in the browser. Verify this: Rmd is quite readable. But the output is obviously not there. HTML is ugly. 4.4.3 Output format Do you really want HTML? Do you only want HTML? If so, you can skip this step! The magical process that turns your R Markdown to HTML is like so: foo.Rmd --&gt; foo.md --&gt; foo.html. Note the intermediate markdown, foo.md. By default RStudio discards this, but you might want to hold on to that markdown. Why? GitHub gives very special treatment to markdown files. They are rendered in an almost HTML-like way. This is great because it preserves all the charms of plain text but gives you a pseudo-webpage for free when you visit the file in the browser. In contrast, HTML is rendered as plain text on GitHub and you’ll have to take special measures to see it the way you want. In many cases, you only want the markdown. In that case, we switch the output format to github_document. This means render will be foo.Rmd --&gt; foo.md, where foo.md is GitHub-flavored markdown. If you still want the HTML but also the intermediate markdown, there’s a way to request that too. Output format is one of the many things we can control in the YAML frontmatter – the text at the top of your file between leading and trailing lines of ---. You can make some changes via the RStudio IDE: click on the “gear” in the top bar of the source editor, near the “Knit HTML” button. Select “Output options” and go to the Advanced tab and check “Keep markdown source file.” Your YAML should now look more like this: --- title: &quot;Something fascinating&quot; author: &quot;Jenny Bryan&quot; date: &quot;2021-01-04&quot; output: html_document: keep_md: true --- You should have gained the line keep_md: true. You can also simply edit the file yourself to achieve this. In fact this hand-edit is necessary if you want to keep only markdown and get GitHub-flavored markdown. In that case, make your YAML look like this: --- title: &quot;Something fascinating&quot; author: &quot;Jenny Bryan&quot; date: &quot;2021-01-04&quot; output: github_document --- Save! You might want to commit here. Render via “Knit HTML” button. Now revisit the file browser. In addition to foo.Rmd, you should now see foo.md. If there are R chunks that make figures, the usage of markdown output formats will also cause those figure files to be left behind in a sensibly named sub-directory, foo_files. If you commit and push foo.md and everything inside foo_files, then anyone with permission to view your GitHub repo can see a decent-looking version of your report. If your output format is html_document, you should still see foo.html. If your output format is github_document and you see foo.html, that’s leftover from earlier experiments. Delete that. It will only confuse you later. You might want to commit here. 4.4.4 Push to GitHub Push the current state to GitHub. Go visit it in the browser. Do you see the modifications and new file(s)? Your Rmd should be modified (the YAML frontmatter changed). And you should have gained at least, the associated markdown file. Visit the markdown file and compare to our previous HTML. Do you see how the markdown is much more useful on GitHub? Internalize that. 4.4.5 Put your stamp on it Select everything but the YAML frontmatter and … delete it! Write a single English sentence. Insert an empty R chunk, via the “Chunk” menu in upper right of source editor or with corresponding keyboard shortcut. ```r ## insert your brilliant WORKING code here ``` Insert 1 to 3 lines of functioning code that begin the task at hand. “Walk through” and run those lines using the “Run” button or the corresponding keyboard shortcut. You MUST make sure your code actually works! Satisfied? Save! You might want to commit here. Now render the whole document via “Knit HTML.” Voilà! You might want to commit here. 4.4.6 Develop your report In this incremental manner, develop your report. Add code to this chunk. Refine it. Add new chunks. Go crazy! But keep running the code “manually” to make sure it works. If it doesn’t work with you babysitting it, I can guarantee you it will fail, in a more spectacular and cryptic way, when run at arms-length via “Knit HTML” or rmarkdown::render(). Clean out your workspace and restart R and re-run everything periodically, if things get weird. There are lots of chunk menu items and keyboard shortcuts to accelerate this workflow. Render the whole document often to catch errors when they’re easy to pinpoint and fix. Save often and commit every time you reach a point that you’d like as a “fall back” position. You’ll develop your own mojo soon, but this should give you your first successful R Markdown experience. 4.4.7 Publish your report If you’ve been making HTML, you can put that up on the web somewhere, email to your collaborator, whatever. No matter what, technically you can publish this report merely by pushing a rendered version to GitHub. However, certain practices make this effort at publishing more satisfying for your audience. Here are two behaviors I find very frustrating: “Here is my code. Behold.” This is when someone only pushes their source, i.e. R Markdown or R code AND they want other people to look at their “product”. The implicit assumption is that target audience will download code and run it. Sometimes the potential payoff simply does not justify this effort. “Here is my HTML. Behold.” This is when someone doesn’t bother to edit the default output format and accepts HTML only. What am I supposed to do with HTML on GitHub? Creating, committing, and pushing markdown is a very functional, lighweight publishing strategy. Use output: github_document or keep_md: true if output is html_document. In both cases, it is critical to also commit and push everything inside foo_files. Now people can visit and consume your work like any other webpage. This is (sort of) another example of keeping things machine- and human-readable, which is bliss. By making foo.Rmd available, others can see and run your actual code. By sharing foo.md and/or foo.html, others can casually browse your end product and decide if they even want to bother. 4.4.8 HTML on GitHub HTML files, such as foo.html, are not immediately useful on GitHub (though your local versions are easily viewable). Visit one and you’ll see the raw HTML. Yuck. But there are ways to get a preview: such as http://htmlpreview.github.io. Expect much pain with HTML files inside private repos (hence the recommendations above to emphasize markdown). When it becomes vital for the whole world to see proper HTML in its full glory, it’s time to use a more sophisticated web publishing strategy. I have more general ideas about how to make a GitHub repo function as a website. 4.4.9 Troubleshooting Make sure RStudio and the rmarkdown package (and its dependencies) are up-to-date. In case of catastrophic failure to render the boilerplate R Markdown document, consider that your software may be too old. Details on the system used to render this document and how to check your setup: rmarkdown version 2.6. Use packageVersion(\"rmarkdown\") to check yours. R version 4.0.3 (2020-10-10). Use R.version.string to check yours. RStudio IDE 1.2.1555. Use RStudio &gt; About RStudio or RStudio.Version()$version to check yours. Get rid of your .Rprofile, at least temporarily. I have found that a “mature” .Rprofile that has accumulated haphazardly over the years can cause trouble. Specifically, if you’ve got anything in there relating to knitr, markdown, rmarkdown and RStudio itself, it may be preventing the installation or usage of the most recent goodies. Comment the whole file out or rename it something else and relaunch or even re-install RStudio. “I have ignored your advice and dumped a bunch of code in at once. Now my Rmd does not render.” If you can’t figure out what’s wrong by reading the error messages, pick one: Back out of these changes, get back to a functional state (possibly with no code), and restore them gradually. Run your code interactively to make sure it works. Render the entire document frequently. Commit after each successful addition! When you re-introduce the broken code, now it will be part of a small change and the root problem will be much easier to pinpoint and fix. Tell knitr to soldier on, even in the presence of errors. Some problems are easier to diagnose if you can execute specific R statements during rendering and leave more evidence behind for forensic examination. Insert this chunk near the top of your .Rmd document: - If it&#39;s undesirable to globally accept errors, you can still do this for a specific chunk like so: ```r ## your sketchy code goes here ;) ``` Adapt the “git bisect” strategy: Put knitr::knit_exit() somewhere early in your .Rmd document, either in inline R code or in a chunk. Keep moving it earlier until things work. Now move it down in the document. Eventually you’ll be able to narrow down the location of your broken code well enough to find the line(s) and fix it. Check your working directory. It’s going to break your heart as you learn how often your mistakes are really mundane and basic. Ask me how I know. When things go wrong consider: What is the working directory? Is that file I want to read/write actually where I think it is? Drop these commands into R chunks to check the above: getwd() will display working directory at run time. If you monkeyed around with working directory with, e.g., the mouse, maybe it’s set to one place for your interactive development and another when “Knit HTML” takes over? list.files() will list the files in working directory. Is the file you want even there? Don’t try to change working directory within an R Markdown document. Just don’t. See knitr FAQ #5. That is all. Don’t be in a hurry to create a complicated sub-directory structure. RStudio/knitr/rmarkdown (which bring you the “Knit HTML” button) are rather opinionated about the working directory being set to the .Rmd file’s location and about all files living together in one big happy directory. This can all be worked around. For example, I recommend the here package for building file paths, once you require sub-directories. But don’t do this until you really need it. 4.5 Render an R script An under-appreciated fact is that much of what you can do with R Markdown, you can also do with an R script. If you’re in analysis mode and want a report as a side effect, write an R script. If you’re writing a report with a lot of R code in it, write Rmd. In either case, render to markdown and/or HTML to communicate with other human beings. In R markdown, prose is top-level and code is tucked into chunks. In R scripts, code is top-level and prose is tucked into comments. You will use #' to request that certain comments appear as top-level prose in the rendered output. You will continue to specify things like the output format via YAML at the top of the file. This will need to be commented with #'. 4.5.1 Morph R Markdown into a renderable R script Get yourself a working R Markdown file, such as the one you made in your Rmd test drive. Or use the boilerplate Rmd document RStudio makes with File &gt; New File &gt; R Markdown …. Save the file as foo.R, as opposed to foo.Rmd. Yes, for a brief moment, you will have R Markdown saved as an R script, but that won’t be true for long. Transform the Rmd to R: Anything that’s not R code? Like the YAML and the English prose? Protect it with roxygen-style comments: start each line with #'. Anything that’s R code? Let it exist “as is” as top-level code. That means you’ll need to change the syntax of R chunk headers like so: Before: ```{r setup, include = FALSE} After: #+ r setup, include = FALSE Replace the leading backticks and opening curly brace with #+. Delete the trailing curly brace. Delete the 3 backticks that end each chunk. Render the R script through one of these methods: Click on the “notebook” icon in RStudio to “Compile Report”. In RStudio, do File &gt; Knit Document. In R, do rmarkdown::render(\"foo.R\"). You’ll get a markdown and/or HTML report, just as with R Markdown. If you’re having trouble making all the necessary changes and you’re frustrated, see below for an example you can copy and paste. All the workflow tips from the Rmd test drive apply here: when you script an analysis, render it to markdown, commit the .R, the .md, any associated figures, and push to GitHub. Collaborators can see your code but also browse the result without running it. This makes the current state of your analysis accessible to someone who does not even run R or who wants to take a quick look at things from a cell phone or while on vacation. 4.5.2 Write a render-ready R script Instead of morphing an R Markdown file, let’s create a render-ready R script directly. Create a new R script and copy/paste this code into it. #&#39; Here&#39;s some prose in a very special comment. Let&#39;s summarize the built-in #&#39; dataset `VADeaths`. ## here is a regular code comment, that will remain as such summary(VADeaths) #&#39; Here&#39;s some more prose. I can use usual markdown syntax to make things #&#39; **bold** or *italics*. Let&#39;s use an example from the `dotchart()` help to #&#39; make a Cleveland dot plot from the `VADeaths` data. I even bother to name #&#39; this chunk, so the resulting PNG has a decent name. #+ dotchart dotchart(VADeaths, main = &quot;Death Rates in Virginia - 1940&quot;) Render the R script through one of these methods: Click on the “notebook” icon in RStudio to “Compile Report”. In RStudio, do File &gt; Knit Document. In R, do rmarkdown::render(\"YOURSCRIPT.R\"). Revel in your attractive looking report with almost zero effort! Seriously, all you had to do was think about when to use special comments #' in order to promote that to nicely rendered text. Drawing on the workflow tips in Rmd test drive, let’s add some YAML frontmatter, properly commented with #', and request the github_document. Here’s the whole script again: #&#39; --- #&#39; title: &quot;R scripts can be rendered!&quot; #&#39; author: &quot;Jenny Bryan&quot; #&#39; date: &quot;April 1, 2014&quot; #&#39; output: github_document #&#39; --- #&#39; #&#39; Here&#39;s some prose in a very special comment. Let&#39;s summarize the built-in #&#39; dataset `VADeaths`. ## here is a regular code comment, that will remain as such summary(VADeaths) #&#39; Here&#39;s some more prose. I can use usual markdown syntax to make things #&#39; **bold** or *italics*. Let&#39;s use an example from the `dotchart()` help to #&#39; make a Cleveland dot plot from the `VADeaths` data. I even bother to name #&#39; this chunk, so the resulting PNG has a decent name. #+ dotchart dotchart(VADeaths, main = &quot;Death Rates in Virginia - 1940&quot;) Behind the scenes here we have used rmarkdown::render() to render this script and you can go visit it on GitHub. "],["git-intro.html", "Chapter 5 Some Git basics 5.1 Repo, commit, diff, tag 5.2 Git commands 5.3 Branches 5.4 Remotes", " Chapter 5 Some Git basics We’ve told you shockingly little about Git so far! This is by design. We find that actual usage, in the course of your work, is the most effective way to build up a useful mental model for Git. However, building on this early success, now is the perfect time to explicitly define some Git vocabulary. We also want to help you link Git concepts to data science tasks and projects. This part collects anything we’ve written about core Git concepts. It is a work in progress and is conceived as a complement to the many excellent external resources for Git, which we have no desire to re-invent. 5.1 Repo, commit, diff, tag 5.1.1 Repos or repositories Git is a version control system whose original purpose was to help groups of developers work collaboratively on big software projects. Git manages the evolution of a set of files – called a repository or repo – in a highly structured way. Historically, these files would have consisted of source code and the instructions for how to build an application from its source. Git has been re-purposed by the data science community (Ram 2013; Bartlett 2016; Perez-Riverol et al. 2016). We use it to manage the motley collection of files that make up typical data analytical projects, which consist of data, figures, reports, and, yes, some source code. For new or existing projects, we recommend that you: Dedicate a local directory or folder to it. Make it an RStudio Project. Optional but recommended; obviously only applies to projects involving R and users of RStudio. Make it a Git repository. This setup happens once per project and can happen at project inception or at any later point. Chances are your existing projects each already live in a dedicated directory. Making such a directory an RStudio Project and Git repository boils down to allowing those applications to leave notes for themselves in hidden files or directories. The project is still a regular directory on your computer, that you can locate, name, move, and generally interact with as you wish. You don’t have to handle it with special gloves! The daily workflow is probably not dramatically different from what you do currently. You work in the usual way, writing R scripts or authoring reports in LaTeX or R Markdown. But instead of only saving individual files, periodically you make a commit, which takes a snapshot of all the files in the entire project. If you have ever versioned a file by adding your initials or the date, you have effectively made a commit, albeit only for a single file. It is a version that is significant to you and that you might want to inspect or revert to later. Periodically, you push commits to GitHub. This is like sharing a document with colleagues on DropBox or sending it out as an email attachment. By pushing to GitHub, you make your work and all your accumulated progress accessible to others. This is a moderate change to your normal, daily workflow. It feels weird at first, but quickly becomes second nature. 5.1.2 Commits, diffs, and tags We now connect the fundamental concepts of Git to the data science workflow: repository commit diff Recall that a repository or repo is just a directory of files that Git manages holistically. A commit functions like a snapshot of all the files in the repo, at a specific moment. Under the hood, that is not exactly how Git implements things. Although mental models don’t have to be accurate in order to be useful, in this case it helps to align the two. Figure 5.1: Partial commit history for our iris example, highlighting diffs, commit messages, SHAs, and tags. Figure 5.1 is a look at a fictional analysis of the iris data, focusing on the evolution of a script, iris.R. Consider version A of this file and a modified version, version B. Assume that version A was part of one Git commit and version B was part of the next commit. The set of differences between A and B is called a “diff” and Git users contemplate diffs a lot. Diff inspection is how you re-explain to yourself how version A differs from version B. Diff inspection is not limited to adjacent commits. You can inspect the diffs between any two commits. In fact, Git’s notion of any specific version of iris.R is as an accumulation of diffs. If you go back far enough, you find the commit where the file was created in the first place. Every later version is stored by Git as that initial version, plus all the intervening diffs in the history that affect the file. We’ll set these internal details aside now, but understanding the importance of these deltas will make Git’s operations less baffling in the long run. So, by looking at diffs, it’s easy to see how two snapshots differ, but what about the why? Every time you make a commit you must also write a short commit message. Ideally, this conveys the motivation for the change. Remember, the diff will show the content. When you revisit a project after a break or need to digest recent changes made by a colleague, looking at the history, by reading commit messages and skimming through diffs, is an extremely efficient way to get up to speed. Figure 5.1 shows the messages associated with the last three commits. Every commit needs some sort of nickname, so you can identify it. Git does this automatically, assigning each commit what is called a SHA, a seemingly random string of 40 letters and numbers (it is not, in fact, random but is a SHA-1 checksum hash of the commit). Though you will be exposed to these, you don’t have to handle them directly very often and, when you do, usually the first 7 characters suffice. The commit messages in Figure 5.1 are prefixed by such truncated SHAs. You can also designate certain snapshots as special with a tag, which is a name of your choosing. In a software project, it is typical to tag a release with its version, e.g., “v1.0.3”. For a manuscript or analytical project, you might tag the version submitted to a journal or transmitted to external collaborators. Figure 5.1 shows a tag, “draft-01”, associated with the last commit. 5.2 Git commands A collection of some of the Git commands that have been largely going on under the hood. We’ve emphasized early workflows that are possible in RStudio. But all of this and much more can be done from the command line. This list is here mostly so we can consult it during live workshops if needed. Unless you use the GitHub API, most of the GitHub bits really have to be done from the browser. New local git repo from a repo on GitHub: git clone https://github.com/jennybc/happy-git-with-r.git Check the remote was cloned successfully: git remote --verbose Stage local changes, commit: git add foo.txt git commit --message &quot;A commit message&quot; Check on the state of the Git world: git status git log git log --oneline Compare versions: git diff Add a remote to existing local repo: git remote add origin https://github.com/jennybc/happy-git-with-r git remote --verbose git remote show origin Push local master to GitHub master and have local master track master on GitHub: git push --set-upstream origin master ## shorter form git push -u origin master ## you only need to set upstream tracking once! Regular push: git push ## the above usually implies (and certainly does in our tutorial) git push origin master ## git push [remote-name] [branch-name] Pull commits from GitHub: git pull Pull commits and don’t let it put you in a merge conflict pickle: git pull --ff-only Fetch commits git fetch Switch to a branch git checkout [branch-name] Checking remote and branch tracking git remote -v git branch -vv 5.3 Branches Branching means that you take a detour from the main stream of development and do work without changing the main stream. It allows one or many people to work in parallel without overwriting each other’s work. Branching in git is very lightweight, which means creating a branch and switching between branches is nearly instantaneous. This means git encourages workflows which create small branches for exploration or new features, often merging them back together quickly. 5.3.1 Create a new branch You can create a new branch with git branch, then checkout the branch with git checkout. To distinguish it from the main stream of development, presumably on master, we’ll call this a “feature branch”. git branch issue-5 git checkout issue-5 You can also use the shortcut git checkout -b issue-5 to create and checkout the branch all at once. Once you have switched to a branch, you can commit to it as usual. 5.3.2 Switching branches You use git checkout to switch between branches. But what do you do if you are working on a branch and need to switch, but the work on the current branch is not complete? One option is the Git stash, but generally a better option is to safeguard the current state with a temporary commit. Here I use “WIP” as the commit message to indicate work in progress. git commit --all -m &quot;WIP&quot; git checkout master Then when you come back to the branch and continue your work, you need to undo the temporary commit by resetting your state. Specifically, we want a mixed reset. This is “working directory safe”, i.e. it does not affect the state of any files. But it does peel off the temporary WIP commit. Below, the reference HEAD^ says to roll the commit state back to the parent of the current commit (HEAD). git checkout issue-5 git reset HEAD^ If this is difficult to remember, or to roll the commit state back to a different previous state, the reference can also be given as the SHA of a specific commit, which you can see via git log. 5.3.3 Merging a branch Once you have done your work and committed it to the feature branch, you can switch back to master and merge the feature branch. git checkout master git merge issue-5 5.3.4 Dealing with conflicts Most of the time, the merge will go smoothly. However if both the branches you are merging changed the same part of the same file you will get a merge conflict. git merge issue-5 # Auto-merging index.html # CONFLICT (content): Merge conflict in index.html # Automatic merge failed; fix conflicts and then commit the result. The first thing to do is NOT PANIC. Merge conflicts are not the end of the world and most are relatively small and straightforward to resolve. The first step to solving a merge conflict is determining which files are in conflict, which you can do with git status: git status # On branch master # You have unmerged paths. # (fix conflicts and run &quot;git commit&quot;) # # Unmerged paths: # (use &quot;git add &lt;file&gt;...&quot; to mark resolution) # # both modified: index.html # # no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) So this shows only index.html is unmerged and needs to be resolved. We can then open the file to see what lines are in conflict. &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html &lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt; ======= &lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com &lt;/div&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; issue-5:index.html In this conflict, the lines between &lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html and ====== are the content from the branch you are currently on. The lines between ======= and &gt;&gt;&gt;&gt;&gt;&gt;&gt; issue-5:index.html are from the feature branch we are merging. To resolve the conflict, edit this section until it reflects the state you want in the merged result. Pick one version or the other or create a hybrid. Also remove the conflict markers &lt;&lt;&lt;&lt;&lt;&lt;, ====== and &gt;&gt;&gt;&gt;&gt;&gt;. &lt;div id=&quot;footer&quot;&gt; please contact us at email.support@github.com &lt;/div&gt; Now run git add index.html and git commit to finalize the merge. CONFLICTS RESOLVED. 5.3.4.1 Bailing out If, during the merge, you get confused about the state of things or make a mistake, use git merge --abort to abort the merge and go back to the state prior to running git merge. Then you can try to complete the merge again. Git Basic Branching and Merging: https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging 5.4 Remotes Remote repositories are versions of your project that are hosted on the Internet or another network. A single project can have 1, 2 or even hundreds of remotes. You pull others changes from remotes and push your changes to remotes. 5.4.1 Listing what remotes exist git remote lists the names of available remotes, but usually it is more useful to see what URLs each note corresponds to (with -v). git remote -v ## origin https://github.com/ibecav/happy-git-with-r (fetch) ## origin https://github.com/ibecav/happy-git-with-r (push) ## upstream https://github.com/jennybc/happy-git-with-r.git (fetch) ## upstream https://github.com/jennybc/happy-git-with-r.git (push) 5.4.2 Adding a new remote git clone automatically adds a new remote, so often you do not need to do this manually initially. However, after the initial clone, it is often useful to add additional remotes. Use git remote add to add a new remote git remote add happygit https://github.com/jennybc/happy-git-with-r.git Note: when you add a remote you give it a nickname (here happygit), which you can use in git commands in place of the entire URL. git fetch happygit Sidebar on nicknames: there is a strong convention to use origin as the nickname of your main remote. At this point, it is common for the main remote of a repo to be hosted on GitHub (or GitLab or Bitbucket). It is tempting to use a more descriptive nickname (such as github), but you might find that following convention is worth it. It makes your setup easier for others to understand and for you to transfer information that you read in documentation, on Stack Overflow, or in blogs. A common reason to add a second remote is when you have done a “fork and clone” of a repo and your personal copy is set up as the origin remote. Eventually you will want to pull changes from the original repository. It is common to use upstream as the nickname for this remote. 5.4.3 Fetching data from remotes To get new data from a remote use git fetch &lt;remote_name&gt;. This retrieves the data locally, but importantly it does not change the state of your repository or your files in any way. To incorporate the data into your repository, you need to merge or rebase your project with the remote project. # Fetch the data git fetch happygit # Now merge it with our local master git merge happygit/master master # git pull is a shortcut which does the above in one command git pull happygit master For more detail on git pull workflows, see 7.3. 5.4.4 Pushing to remotes Use git push &lt;remote&gt; &lt;branch&gt; to push your local changes to the &lt;branch&gt; branch on the &lt;remote&gt; remote. # push my local changes to the origin remote&#39;s master branch git push origin master # push my local changes to the happygit remote&#39;s test branch git push happygit test 5.4.5 Renaming and changing remotes git remote rename can be used to rename a remote git remote rename happygit hg git remote set-url can be used to change the URL for a remote. This is sometimes useful if you initially set up a remote using https, but now want to use the SSH URL instead (or vise versa). git remote set-url happygit git@github.com:jennybc/happy-git-with-r.git One fairly common workflow is you initially cloned a repository on GitHub locally (without forking it), but now want to create your own fork and push changes to it. As described earlier, it is common to call the main repository upstream and to call your fork origin. So, in this case, you need to first rename the existing remote (from origin to upstream). Then add your fork as a new remote, with the name origin. git remote rename origin upstream git remote add origin git@github.com:jimhester/happy-git-with-r.git 5.4.6 Upstream tracking branches It is possible to set the branch on the remote each of your local remotes corresponds to. git clone sets this up automatically, so for your own master branch this is not something you will run into. However by default if you create a new branch and try to push to it you will see something like this. git checkout -b mybranch git push # fatal: The current branch foo has no upstream branch. # To push the current branch and set the remote as upstream, use # # git push --set-upstream origin foo You can do as the error message says and explicitly set the upstream branch with --set-upstream. However I would recommend instead changing the default behavior of push to automatically set the upstream branch to the branch with the same name on the remote. You can do this by changing the git push.default option to current. git config --global push.default current See also Working with Remotes: https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes "],["remote-scenarios-intro.html", "Chapter 6 Git remote setups 6.1 No GitHub 6.2 All Yours 6.3 Ours 6.4 Fork (of theirs) 6.5 Fork (salvageable)", " Chapter 6 Git remote setups The previous part ended with some basics about Git remotes, such as how to define or rename one. Recall that a Git remote is another copy of the repo, usually living elsewhere (hence the term “remote”), that you can pull changes from or push changes to. Remotes are the foundation for all collaborative Git work. But knowing the mechanics of how to add or rename a remote does little good if you don’t know why or when to do it. Luckily, we have very strong opinions about how you should set up your remotes, all motivated by getting you prepared for smooth, happy collaborative work. In this part we describe various remote setups that are common (for better or worse) and what they are good for (or what’s wrong with them and how to fix). We only consider a very constrained set of remotes here: The remote is on GitHub, e.g. its URL looks something like https://github.com/OWNER/REPO.git or git@github.com:OWNER/REPO.git. The remote is named origin or upstream. These may not be the most evocative names in the world, but they are the most common choices. If you use a different host or different remote names, you should still be able to translate these examples to your setting. Along the way, we note how these setups relate to the usethis package, i.e. how usethis can help you get into a favorable setup or how a favorable setup unlocks the full power of usethis. Many of these operations – including characterizing your GitHub remotes – require that you have configured a GitHub personal access token. See section D.1 for more details on why and how to do that. If you don’t use usethis, feel free to ignore these asides. 2020-10 note: this currently refers to features in a development version of usethis. These features will appear in usethis v2.0.0. 6.1 No GitHub As a starting point, consider a local Git repo that is not yet connected to GitHub. This is not very exciting, but sets the stage for what’s to come. We introduce the icon we use for a Git repo, which looks like a stack of coins or a barrel. This one is blue, which indicates you have write permission. How to achieve: With RStudio: Existing Project: Tools &gt; Version Control &gt; Project Setup, select Git as the version control system New Project: Make sure “Create a Git repository” is selected With usethis, existing project: usethis::use_git() Command line Git: git init usethis describes this setup as “no_github”. 6.2 All Yours A common next step is to associate a local repo with a copy on GitHub, owned by you. A remote named origin is configured and you have permission to push to (and pull from) origin. (That’s why origin is colored blue and there are solid arrows going both directions.) The origin remote on GitHub is what we’ll call a source repo, meaning it is not a fork (i.e. copy) of anything else on GitHub. In this case, origin is also what we’ll call your primary repo, meaning it is the primary remote you interact with on GitHub (for this project). How to achieve if the local repo exists first: Command line Git or RStudio: You can’t complete this task fully from the command line or from RStudio: Create a new GitHub repo in the browser, with the correct name, and capture its HTTPS or SSH URL Command line: git remote add origin &lt;URL&gt; In RStudio, click the New Branch button, which brings up a window where you can create the origin remote with this URL. This workflow is described in Existing project, GitHub last. Even now, the setup may not be ideal, because upstream tracking relationships are probably not setup, which means you may not be able to push and pull easily. You may need to explicitly configure an upstream tracking branch for one or more local branches. Next time you want to create a GitHub repo from a local repo, consider using usethis::use_github(), which completes all of this setup in one go. With usethis: usethis::use_github() How to achieve if the remote repo exists first: In RStudio: Capture the source repo’s HTTPS or SSH URL and do File &gt; New Project &gt; Version Control &gt; Git, described more fully in New RStudio Project via git clone With usethis: usethis::create_from_github(\"OWNER/REPO\", fork = FALSE) Command line: git clone &lt;URL&gt;, with the source repo’s HTTPS or SSH URL usethis describes this setup as “ours”. 6.3 Ours Here is a variation on “ours” that is equivalent in practice. A remote named origin is configured and you can push to (and pull from) origin. As above, origin is a source repo, meaning it is not a fork (or copy) of anything else on GitHub. The origin remote is, however, not owned by you. Instead it’s owned by another GitHub user or organisation. origin is also your primary repo in this setup. How does this happen? The source repo is owned by an organisation and your role in this organisation confers enough power to create repos or to push to this repo. The owner of the source repo has added you, specifically, as a collaborator to this specific repo. How to achieve? The procedure is the same as for the previous “ours” setup. But remember to specify usethis::use_github(organisation = \"ORGNAME\") if you want to create a new repo under an organisation, instead of your personal account. usethis describes this setup as “ours”. 6.4 Fork (of theirs) This is an ideal setup if you want to make a pull request and generally follow the development of a source repo owned by someone else. This shows a successful “fork-and-clone”. Your local repo can pull changes from the source repo, which is configured as upstream, which you cannot push to (but you can pull from). You have a fork of the source repo (a very special copy, on GitHub) and it is configured as origin. origin is your primary repo. You can push to and pull from origin. You can make a pull request back to the source repo via your fork. How to achieve: Command line Git or RStudio: You can’t complete this task fully from the command line or RStudio: Fork the source repo in the browser, capture the HTTPS or SSH URL of your fork, then use git remote clone &lt;FORK_URL&gt; (command line) or RStudio’s File &gt; New Project &gt; Version Control &gt; Git workflow. But, wait, you’re not done! If you stop here, you will have the incomplete setup we refer to as “fork (salvageable)”, below. You still need to add the source repo as the upstream remote. Capture the HTTPS or SSH URL of the source repo. At the command line, do git remote add upstream &lt;SOURCE_URL&gt; or click RStudio’s New Branch button, which brings up a window where you can add the upstream remote. Even then, the setup may not be ideal, because your local default branch is probably tracking origin, not upstream, which is preferable for a fork. usethis::create_from_github() completes all of this setup in one go. With usethis: usethis::create_from_github(\"OWNER/REPO\", fork = TRUE) 6.5 Fork (salvageable) Here is one last fork setup that’s sub-optimal, but it can be salvaged. This is what happens when you do fork-and-clone and you only do fork-and-clone. What’s missing is a connection back to the source repo. How does this happen? Cloning your own fork, either via git clone in the shell or through a Git client, such as RStudio. And then stopping here. If you only plan to make one pull request, this setup is fine. When the exchange is done, delete your local repo and your fork and move on with your life. You can always re-fork in the future. But if your pull request stays open for a while or if you plan to make repeated contributions, you’ll need to pull ongoing developments in the source repo into your local copy. Fix this by adding the source repo as your upstream remote. Capture the HTTP or SSH URL of the source repo and then: With usethis: usethis::use_git_remote(name = \"upstream\", url = \"SOURCE_URL\") Command line Git: git remote add upstream &lt;SOURCE_URL&gt; With RStudio: click the New Branch button, which brings up a window where you can add the upstream remote with this URL. Even now, the setup may not be ideal, because your local default branch is probably tracking origin, not upstream, which is preferable for a fork. Next time you do fork-and-clone, consider using usethis::create_from_github(fork = TRUE) instead, which completes all of this setup in one go. usethis describes this setup as “fork_upstream_is_not_origin_parent”. "],["workflows-intro.html", "Chapter 7 Useful Git patterns for real life 7.1 The Repeated Amend 7.2 Dealing with push rejection 7.3 Pull, but you have local work 7.4 Local work is uncommitted 7.5 Time travel: See the past 7.6 Fork and clone 7.7 Get upstream changes for a fork 7.8 Get upstream changes for a fork 7.9 Make a GitHub repo browsable 7.10 Links and embedded figures", " Chapter 7 Useful Git patterns for real life Git patterns that come up frequently in real work: Commit early and often. Push less often. The Repeated Amend. Help, my push was rejected! Integrating remote and local work. Probably so you can push again. Burn it all down. Time travel: “I just need to see the past”. Browse and search on GitHub. “I need to visit the past”. Create a checkout a branch. “I want to return to the past”. git revert, git reset “I had a great cookie last October”. git cherry pick, git checkout REF -- path Play well with others: Fork and clone. Get upstream changes for a fork. Disposable fork. Make your repo rewarding to browse on GitHub. Explore and extend a pull request 7.1 The Repeated Amend One of the principal joys of version control is the freedom to experiment without fear. If you make a mess of things, you can always go back to a happier version of your project. We describe several methods of such time travel in link to come. But you must have a good commit to fall back to! 7.1.1 Rock climbing analogy Using a Git commit is like using anchors and other protection when climbing. If you’re crossing a dangerous rock face you want to make sure you’ve used protection to catch you if you fall. Commits play a similar role: if you make a mistake, you can’t fall past the previous commit. Coding without commits is like free-climbing: you can travel much faster in the short-term, but in the long-term the chances of catastrophic failure are high! Like rock climbing protection, you want to be judicious in your use of commits. Committing too frequently will slow your progress; use more commits when you’re in uncertain or dangerous territory. Commits are also helpful to others, because they show your journey, not just the destination. R Packages, Hadley Wickham (Wickham (2015)) Let’s talk about this: use more commits when you’re in uncertain or dangerous territory When I’m doing something tricky, I often proceed towards my goal in small increments, checking that everything still works along the way. Yes it works? Make a commit. This is my new worst case scenario. Keep going. What’s not to love? This can lead to an awful lot of tiny commits. This is absolutely fine and nothing to be ashamed of. But one day you may start to care about the utility and aesthetics of your Git history. The Repeated Amend is a pattern where, instead of cluttering your history with lots of tiny commits, you build up a “good” commit gradually, by amending. Yes, there are other ways to do this, e.g. via squashing and interactive rebase, but I think amending is the best way to get started. 7.1.2 Workflow sketch 7.1.2.1 Initial condition Start with your project in a functional state: R package? Run your tests or R CMD check. Data analysis? Re-run your script or re-render your .Rmd with the new chunk. Website or book? Make sure the project still compiles. You get the idea. Make sure your “working tree is clean” and you are synced up with your GitHub remote. git status should show something like: On branch master Your branch is up to date with &#39;origin/master&#39;. nothing to commit, working tree clean 7.1.2.2 Get to work Imagine we start at commit C, with previous commit B and, before that, A: ... -- A -- B -- C Make a small step towards your goal. Re-check that your project “works”. Stage those changes and make a commit with the message “WIP”, meaning “work in progress”. Do this in RStudio or in the shell (Appendix A): git commit -m &quot;WIP&quot; The message can be anything, but “WIP” is a common convention. If you use it, whenever you return to a project where the most recent commit message is “WIP”, you’ll know that you were probably in the middle of something. If you push a “WIP” commit, on purpose or by mistake, it signals to other people that more commits might be coming. Your history now looks like this: A -- B -- C -- WIP* Don’t push! The * above signifies a commit that exists only in your local repo, not (yet) on GitHub. Do a bit more work. Re-check that your project is still in a functional state. Commit again but this time amend your previous commit. RStudio offers a check box for “Amend previous commit” or in the shell: git commit --amend --no-edit The --no-edit part retains the current commit message of “WIP”. Don’t push! Your history now looks like this: A -- B -- C -- WIP* but the changes associated with the WIP* commit now represent your last two commits, i.e. all the accumulated changes since state C. Keep going like this. Let’s say you’ve finally achieved your goal. One last time, check that your project is functional and in a state you’re willing to share with others. Commit, amending again, but with a real commit message this time. Think of this as commit D. Push. Do this in RStudio or the shell: git commit --amend -m &quot;Implement awesome feature; closes #43&quot; git push Your history – and that on GitHub – look like this: A -- B -- C -- D As far as the world knows, you implemented the feature in one fell swoop. But you got to work on the task incrementally, with the peace of mind that you could never truly break things. 7.1.3 What if I need to fall back? Imagine you’re in the middle of a Repeated Amend workflow: A -- B -- C -- WIP* and you make some changes that break your project, e.g. tests start failing. These bad changes are not yet committed, but they are saved. You want to fall back to the last good state, represented by WIP*. In Git lingo, you want to do a hard reset to the WIP* state. With the command line: git reset --hard which is implicitly the same as git reset --hard HEAD which says: “reset my files to their state at the most recent commit”. This is also possible in RStudio. Click on “Diff” or “Commit”. Select a file with changes you do not want. Use “Discard All” to discard all changes in that file. Use “Discard chunk” to discard changes in that file, selectively. Repeat this procedure for each affected file until you are back to an acceptable state. Carry on. If you committed a bad state, go to link to come for more reset scenarios. 7.1.4 Why don’t we push intermediate progress? Amending a commit is an example of what’s called “rewriting Git history”. Rewriting history that has already been pushed to GitHub – and therefore potentially pulled by someone else – is a controversial practice. Like most controversial practices, lots of people still indulge in it, as do I. But there is the very real possibility that you create headaches for yourself and others, so in Happy Git we must recommend that you abstain. Once you’ve pushed something, consider it written in stone and move on. 7.1.5 Um, what if I did push? I told you not to! But OK here we are. Let’s imagine you pushed this state to GitHub by mistake: A -- B -- C -- WIP (85bf30a) and proceeded to git commit --amend again locally, leading to this state: A -- B -- C -- WIP* (6e884e6) I’m deliberately showing two histories that sort of look the same, in terms of commit messages. But the last SHA reveals they are actually different. You are in a pickle now, as you can’t do a simple push or pull. A push will be rejected and a pull will probably lead to a merge that you don’t want. You have two choices: Hard reset your local repo to C (git reset --hard HEAD^) and pull from GitHub. Do this if you have collaborators who may have pulled that state. GitHub and local history now show this: A -- B -- C -- WIP (85bf30a) Force push to GitHub (git push --force). Do this if you have no collaborators or you have reason to believe they have not pulled. GitHub and local history now show this: A -- B -- C -- WIP* (6e884e6) Now you are synced up again. 7.2 Dealing with push rejection Problem: You want to push changes to GitHub, but you are rejected like so: $ git push To https://github.com/YOU/REPO.git ! [rejected] master -&gt; master (fetch first) error: failed to push some refs to &#39;https://github.com/YOU/REPO.git&#39; hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., &#39;git pull ...&#39;) before pushing again. hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details. This means that your local Git history and that on the GitHub remote are not compatible, i.e. they have diverged. I suggest that you use git status, your Git client, or visit your GitHub remote in the browser to get more information about the situation, i.e. to get a sense of this work that you do not have. In the abstract, this is the state on GitHub: A -- B -- C (on GitHub) And this is your local state: A -- B -- D (what you have) You can’t cause some sort of merge to happen to the GitHub copy when you push. Instead, you’ve got pull the commit C and somehow integrate it into your D-containing history. Then you will be able to push again. This is covered in the workflow Pull, but you have local work. But before you behold the full horror of that, this is a great time to reflect on what we can learn from this situation. 7.2.1 She who pushes first wins! You may have noticed that you – the author of D – are faffing around with Git more than the person who committed and pushed C, i.e. your collaborator. There is a lesson to be learned here! If you had pushed D first, you’d be relaxing and they’d be figuring out how to integrate C into their history in order to push. So push your work often. Don’t go dark and work “offline” for long stretches of time. Obviously, you should push work to master because it’s “ready” to share (or at least “ready enough”), not to avoid Git merges. There is a truly legitimate point here: It is better for the overall health of a project to be committing, pushing, and integrating more often, not less. This does not eliminate the need to integrate different lines of work, but it makes each integration smaller, less burdensome, and less prone to error. 7.2.2 Stay in touch Another take away is this: the sooner you know about C, the better. Pull (or fetch) often. Let’s think about your commit D. Maybe it was built up over a couple of days via the Repeated Amend pattern. Maybe C was sitting there on GitHub the whole time or appeared very early in your process. Consider that it might be easier to integrate C into your work D sooner rather than later. Sometimes this is not true, but more often it is. In general, it pays off to be proactively aware of what others are doing (e.g. to pull or fetch often) than to always be in reactive mode, learning about your collaborator’s work only when your push is rejected. 7.2.3 Use branches Finally, your early experiences collaborating with others and yourself in master will give you a visceral understanding of why most Git users eventually start to use branches. Branches afford explicit workflows for integrating different lines of work on your own terms. This is much nicer than trying to do a tricky merge or rebase in a frustrated panic, because you need to push your work to GitHub at the end of the day. 7.3 Pull, but you have local work Problem: You want to pull changes from upstream, but you have done some new work locally since the last time you pulled. This often comes up because what you actually want to do is push, but Git won’t let you until you first incorporate the upstream changes. For the sake of simplicity, assume we’re dealing with the master branch and the remote is called origin. Recent commit history of origin/master: A--B--C Recent commit history of the local master branch: A--B--D or maybe A--B--(uncommitted changes) Your goal: get commit C into your local branch, while retaining the work in commit D or your uncommitted changes. Local state is A--B--(uncommitted changes): You could use git stash. Or you could just make a commit to simplify your life (see next bullet). Local state is A--B--D: You can get to A--B--C--D or A--B--(something that includes C and D). Local state is A--B--D--(uncommitted changes): You could just make a commit – a new one or amend D – to simplify your life (see previous bullet). We prioritize simple approaches that are good for early Git use, but mention nicer long-term alternatives. 7.4 Local work is uncommitted Remote state is A--B--C. Local state is A--B--(uncommitted changes). 7.4.0.1 Happy simple cases There are two happy scenarios, in which git pull will “just work”: You’ve introduced completely new files that don’t exist in the remote branch and, therefore, cannot possibly have conflicting changes. You’re in luck! You can just git pull. The files affected by your local work have ZERO overlap with the files affected by the changes you need to pull from the remote. You’re also in luck! You can just git pull. Summary of these happy git pull scenarios: Remote: A--B--C Local before &#39;git pull&#39;: A--B--(uncommitted changes) Local after &#39;git pull&#39;: A--B--C--(uncommitted changes) What has actually happened here is that git pull resulted in a fast-forward merge, i.e. we placed commit C right on the end of your history. This would also be the case in the simpler situation where recent local history was just A--B, i.e. you had not added any local work since the last sync up with origin/master. 7.4.0.2 git stash works, sometimes If your changes affect a file (foo.R in the example below) that has also been changed in commit C, you cannot git pull. It doesn’t hurt to try, but you will fail and it will look something like this: jenny@2015-mbp ethel $ git pull remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 1), reused 1 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. From github.com:jennybc/ethel db046b4..2d33a6f master -&gt; origin/master Updating db046b4..2d33a6f error: Your local changes to the following files would be overwritten by merge: foo.R Please commit your changes or stash them before you merge. Aborting Now what? First, you must safeguard your local changes by either stashing or committing them. (I personally would choose to commit and execute a workflow described in 7.4.1.) I am not a big fan of git stash; I think it’s usually better to take every possible chance to solidify your skills around core concepts and operations, e.g., make a commit, possibly in a branch. But if you want to use git stash, this opportunity is as good as it gets. git stash is a way to temporarily store some changes to get them out of the way. Now you can do something else, without a lot of fuss. In our case, “do something else” is to get the upstream changes with a nice, simple git pull. Then you reapply and delete the stash and pick up where you left off. For more details about stashing, I recommend The stashing coverage in the “Filesystem interactions” chapter of Git in Practice (book website or read on GitHub) 7.3 Git Tools - Stashing and Cleaning in Pro Git. Here’s the best case scenario for “stash, pull, unstash” in the example above: git stash save git pull git stash pop And here’s the output from our example: jenny@2015-mbp ethel $ git stash save Saved working directory and index state WIP on master: db046b4 Merge branch &#39;master&#39;of github.com:jennybc/ethel jenny@2015-mbp ethel $ git pull Updating db046b4..2d33a6f Fast-forward foo.R | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) jenny@2015-mbp ethel $ git stash pop Auto-merging foo.R On branch master Your branch is up-to-date with &#39;origin/master&#39;. Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: foo.R no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Dropped refs/stash@{0} (012c4dcd3a4c3af6757c4c3ca99a9eaeff1eb2a4) That is what success looks like. You’ve achieved this: Remote: A--B--C Local before: A--B--(uncommitted changes) Local after: A--B--C--(uncommitted changes) As above, we have just enjoyed a fast-forward merge, made possible by temporarily stashing then unstashing the uncommitted local changes. 7.4.0.3 git stash with conflicts If your local changes have some overlap with changes you are pulling, you will, instead get a merge conflict from git stash pop. Now you have some remedial work to do. In this case, you have gained nothing by using git stash in the first place, which explains my general lack of enthusiasm for git stash. Here’s how to execute the git stash workflow in our example, in the face of conflicts (based on this Stack Overflow answer): jenny@2015-mbp ethel $ git stash save Saved working directory and index state WIP on master: 2d33a6f Back to 5 jenny@2015-mbp ethel $ git pull Updating 2d33a6f..1eddf9e Fast-forward foo.R | 1 + 1 file changed, 1 insertion(+) jenny@2015-mbp ethel $ git stash pop Auto-merging foo.R CONFLICT (content): Merge conflict in foo.R At this point, you must resolve the merge conflict (future link). Literally, at each locus of conflict, pick one version or the other (upstream or stashed) or create a hybrid yourself. Remove the all the markers inserted to demarcate the conflicts. Save. Since git stash pop did not go smoothly, we need to manually reset (future link) and delete the stash to finish. jenny@2015-mbp ethel $ git reset Unstaged changes after reset: M foo.R jenny@2015-mbp ethel $ git stash drop Dropped refs/stash@{0} (7928db50288e9b4d934803b6b451a000fd7242ed) Phew, we are done. We’ve achieved this: Remote: A--B--C Local before: A--B--(uncommitted changes) Local after: A--B--C--(uncommitted changes*) The asterisk on uncommitted changes* indicates that your uncommitted changes might now reflect adjustments made when you resolved the conflicts. 7.4.1 Local work is committed Remote state is A--B--C. Local state is A--B--D. 7.4.1.1 Pull (fetch and merge) The simplest option is to fetch the commits from upstream and merge them, which is what git pull does. This is a good option if you’re new to Git. It leads to a messier history, but when you are new, this is the least of your worries. Merge, be happy, and carry on. Here is the best case, no-merge-conflicts version of git pull: jenny@2015-mbp ethel $ git pull &lt; YOU WILL PROBABLY BE KICKED INTO AN EDITOR HERE RE: MERGE COMMIT MESSAGE! &gt; Merge made by the &#39;recursive&#39; strategy. README.md | 4 ++-- 1 file changed, 2 insertions(+), 2 deletions(-) Depending on your version of Git, your config, and your use of a GUI, you might be required to confirm/edit a commit message for the merge commit. Or what if things don’t go this smoothly? If commit C (on the remote) and commit D (local) have changes to the same parts of one or more files, Git may not be able to automatically merge and you will get merge conflicts. It will look something like this: jenny@2015-mbp ethel $ git pull Auto-merging foo.R CONFLICT (content): Merge conflict in foo.R Automatic merge failed; fix conflicts and then commit the result. You must resolve these conflicts (future link). Literally, at each locus of conflict, pick one version or the other (upstream or local) or create a hybrid yourself. Remove the all the markers inserted to demarcate the conflicts. Save. Mark the affected file foo.R as resolved via git add and make an explicit git commit to finalize this merge. jenny@2015-mbp ethel $ git add foo.R jenny@2015-mbp ethel $ git commit [master 20b297b] Merge branch &#39;master&#39; of github.com:jennybc/ethel Again, do not be surprised if, during git commit, you find yourself in an editor, confirming/editing the commit message for the merge commit. We’ve achieved this: Remote: A--B--C Local before: A--B--D Local after: A--B--D--(merge commit) \\_C_/ 7.4.1.2 Pull and rebase git pull --rebase creates a nicer history than git pull when integrating local and remote commits. It avoids a merge commit, so the history is less cluttered and is linear. It can make merge conflicts more onerous to resolve, which is why I still recommend git pull as the entry-level solution. Here is the best case, no-merge-conflicts version of git pull --rebase: jenny@2015-mbp ethel $ git pull --rebase First, rewinding head to replay your work on top of it... Applying: Take max Notice that you were NOT kicked into an editor to fiddle with the commit message for the merge commit, because there is no merge commit! This is the beauty of rebasing. We’ve achieved this: Remote: A--B--C Local before: A--B--D Local after: A--B--C--D It is as if we pulled the upstream work in commit C, then did the local work embodied in commit D. We have no cluttery merge commits and a linear history. Nice! The bad news: As with plain vanilla git pull, it is still possible to get merge conflicts with git pull --rebase. If you have multiple local commits, you can even find yourself resolving conflicts over and over, as these commits are sequentially replayed. Hence this is a better fit for more experienced Git users and in situations where conflicts are unlikely (those tend to be correlated, actually). At this point, if you try to do git pull --rebase and get bogged down in merge conflicts, I recommend git rebase --abort to back out. For now, just pursue a more straightforward strategy. 7.4.2 Other approaches There are many more ways to handle this situation, which you can discover and explore as you gain experience and start to care more about the history. We sketch some ideas here. 7.4.2.1 Use a temporary branch for local work Recall: Remote state is A--B--C. Local state is A--B--(uncommitted changes). This is an alternative to the stash workflow that has the advantage of giving you practice with Git techniques that are more generally useful. It also leads to a nice history. Create a new, temporary branch and commit your uncommitted changes there. Checkout master and git pull to get changes from upstream. You now need to recover the work from the commit in the temporary branch. Options: Merge the temporary branch into master. Cherry pick the commit from the temporary branch into master. In either case, it is still possible you will need to deal with merge conflicts. In either case, if you felt forced to commit before you were ready or to accept an ugly merge commit, you can either do a mixed reset to “uncommit” but keep the changes on master or keep amending until you are satisfied with the commit. 7.4.3 Some local work is committed, some is not This is an awkward hybrid situation that can be handled with a combination of strategies seen above: make a pragmatic commit on master or a temporary branch. Integrate the upstream and local changes in master. If you aren’t happy with the final pragmatic commit (which only exists locally), reset or amend until you are. 7.5 Time travel: See the past Sometimes you just need to see various files in your project as they were at some significant moment in the past. Examples: “I liked the color scheme of this plot better in last week’s draft”. “What’s up with that new funky outlier in figure 2?” Here you’ll want to visit scripts and source data as they were the last time you generated visualizations to share with this colleague. “The build has been failing on Windows for two weeks.” Here you’ll want to inspect package source at the “last known good” version and scrutinize subsequent commits. All projects move through various states that you regard as “good” vs. “bad” or something in between. It can be useful to explore the past, when trying to get into a “good” state. 7.5.1 Hyperlinks are awesome! This is where GitHub really shines. The ability to quickly explore different commits/states, switch between branches, inspect individual files, and see the discussion in linked issues is incredibly powerful. Yes, technically, you can visit past states of your project using Git commands locally. But it is significantly more cumbersome. You generally have to checkout these previous states, which raises the prospect of getting comfortable in the “detached head” state and unintentionally making new commits on the wrong branch or on no branch at all. GitHub’s hyperlink-rich presentation of your repo and its history is one of the top reasons to sync local work to a copy on GitHub, even if you keep it private. It can be much easier to hone in on a state or change of interest by clicking around or using GitHub’s search features. Also, because it is so clearly a remote and read-only action, there is no possibility of goofing up local state or committing new work to the wrong branch. 7.5.2 Browse commit history and specific commits From your repo’s landing page, access commit history by clicking on “xyz commits”. This is like using git log locally, but much more rewarding. If you have a good local Git client, it probably also provides a graphical overview of history. Figure 7.1: Link to commit listing on GitHub. Once you’re viewing the history, notice three ways to access more info for each commit: The clipboard icon copies the SHA-1 of the commit. This can be handy if you need to refer to this commit elsewhere, e.g. in an issue thread or a commit message or in a Git command you’re forming for local execution. Click on the abbreviated SHA-1 itself in order to the view the diff associated with the commit. Click on the double angle brackets &lt;&gt; to browse the state of the entire repo at that point in history. Figure 7.2: Example of a commit listing on GitHub. Back out of any drilled down view by clicking on YOU/REPO to return to your repo’s landing page. This brings you back to the present state and top-level of your repo. 7.5.3 Use hyperlinks yourself! Once you’ve identified a relevant commit, diff, or file state, you can copy the current URL from your browser and use it to enhance online discussion elsewhere, i.e. to bring other people to this exact view of the repo. The hyperlink-iness of repos hosted on GitHub can make online discussion of a project much more precise and efficient. 7.5.4 File driven inquiries What if you’re interested in how a specific file came to be the way it is? First navigate to the file, then notice “Blame” and “History” in the upper right. Figure 7.3: Visiting a specific file on GitHub. 7.5.5 Blame The “blame” view of a file is related to what git blame does on the command line. It reveals who last touched each line of the file, how long ago, and the associated commit message. Click on the commit message to visit that commit. Or click the “stacked rectangles” icon to move further back in time, but staying in blame view. This is handy when doing forensics on a specific and small set of lines. 7.5.6 History The “history” view for a file is very much like the overall commit history described above, except it only includes commits that affect the file of interest. This can be handy when your inquiry is rather diffuse and you’re trying to digest the general story arc for a file. 7.5.7 Hyperlink to specific lines at a specific state When viewing a file on GitHub, you can click on a line number to highlight it. Use “click … shift-click” to select a range of lines. Notice your browser’s URL shows something of this form: https://github.com/OWNER/REPO/blob/SHA/path/to/file.R#L27-L31 If the URL does not contain the SHA, type “y” to toggle into that form. These file- and SHA-specific URLs are a great way to point people at particular lines of code in online conversations. It’s best practice to use the uglier links that contain the SHA, as they will stand the test of time. 7.5.8 Search Search is always available in the upper-righthand corner of GitHub. Figure 7.4: Typing into GitHub search bar. Once you enter some text in the search box, a dropdown provides the choice to search in the current repo (the default) or all of GitHub. GitHub searches the contents of files (described as “Code”), commit messages, and issues. Take advantage of the search hits across these different domains. Again, this is a powerful way to zoom in on specific lines of code, revisit an interesting time in project history, or re-discover a conversation thread. 7.5.9 Issue search If you want to search issues specifically, the search box on any repo’s Issues page is prepopulated with the filters is:issue and is:open. 7.6 Fork and clone Use “fork and clone” to get a copy of someone else’s repo if there’s any chance you will want to propose a change to the owner, i.e. send a “pull request”. If you are waffling between “clone” and “fork and clone”, go with “fork and clone”. 7.6.1 Initial workflow On GitHub, make sure you are signed in and navigate to the repo of interest. Think of this as OWNER/REPO, where OWNER is the user or organization who owns the repository named REPO. In the upper right hand corner, click Fork. This creates a copy of REPO in your GitHub account and takes you there in the browser. Now we are looking at YOU/REPO. Clone YOU/REPO, which is your copy of the repo, a.k.a. your fork, to your local machine. You have two options: Existing project, GitHub first, an RStudio workflow we’ve used before. Your fork YOU/REPO plays the role of the existing GitHub repo, in this case – not the original repo! Make a conscious decision about the local destination directory and HTTPS vs SSH URL. Execute git clone https://github.com/YOU/REPO.git (or git clone git@github.com:YOU/REPO.git) in the shell (Appendix A). Clone your fork YOU/REPO– not the original repo! cd to the desired parent directory first. Make a conscious decision about HTTPS vs SSH URL. We’re doing this: 7.6.2 usethis::create_from_github(\"OWNER/REPO\") The usethis package has a convenience function, create_from_github(), that can do “fork and clone”. In fact, it can go even further and set the upstream remote. However, create_from_github() requires that you have configured a GitHub personal access token. It hides lots of detail and can feel quite magical. Due to these difference, we won’t dwell on create_from_github() here. But once you get tired of doing all of this “by hand”, check it out! 7.6.3 Engage with the new repo If you did “fork and clone” via Existing project, GitHub first, you are probably in an RStudio Project for this new repo. Regardless, get yourself into this project, whatever that means for you, using your usual method. Explore the new repo in some suitable way. If it is a package, you could run the tests or check it. If it is a data analysis project, run a script or render an Rmd. Convince yourself that you have gotten the code. 7.6.4 Don’t mess with master If you make any commits in your local repository, I strongly recommend that you work in a new branch, not master. I strongly recommend that you do not make commits to master of a repo you have forked. This will make your life much easier if you want to pull upstream work into your copy. The OWNER of REPO will also be happier to receive your pull request from a non-master branch. 7.6.5 The original repo as a remote Remember we are here: Here is the current situation in words: You have a fork YOU/REPO, which is a repo on GitHub. You have a local clone of your fork. Your fork YOU/REPO is the remote known as origin for your local repo. You are well positioned to make a pull request to OWNER/REPO. But notice the lack of a direct connection between your local copy of this repo and the original OWNER/REPO. This is a problem. As time goes on, the original repository OWNER/REPO will continue to evolve. You probably want the ability to keep your copy up-to-date. In Git lingo, you will need to get the “upstream changes”. See the workflow Get upstream changes for a fork for how to inspect your remotes, add OWNER/REPO as upstream if necessary, and pull changes, i.e. how to complete the “triangle” in the figure above. 7.6.6 No, you can’t do this via GitHub You might hope that GitHub could automatically keep your fork YOU/REPO synced up with the original OWNER/REPO. Or that you could do this in the browser interface. Then you could pull those upstream changes into your local repo. But you can’t. There are some tantalizing, janky ways to sort of do parts of this. But they have fatal flaws that make them unsustainable. I believe you really do need to add upstream as a second remote on your repo and pull from there. 7.7 Get upstream changes for a fork This workflow is relevant if you have done fork and clone and now you need to pull subsequent changes from the original repo into your copy. Sometimes you set this up right away, when you fork and clone, even though you don’t need it yet. Congratulations, you are planning for the future! It’s also very typical to do this step a few days or months later. Maybe you’re taking an interest in someone else’s work for the second time and you want to make another pull request. Or you just want your copy to reflect their recent work. It is also totally normal to set this up upon first need. Vocabulary: OWNER/REPO refers to the original GitHub repo, owned by OWNER, who is not you. YOU/REPO refers to your copy on GitHub, i.e. your fork. 7.7.1 No, you can’t do this via GitHub You might hope that GitHub could automatically keep your fork YOU/REPO synced up with the original OWNER/REPO. Or that you could do this in the browser interface. Then you could pull those upstream changes into your local repo. But you can’t. There are some tantalizing, janky ways to sort of do parts of this. But they have fatal flaws that make them unsustainable. I believe you really do need to add OWNER/REPO as a second remote on your repo and pull from there. 7.7.2 Initial conditions Get into the repo of interest, i.e. your local copy. For many of you, this means launching it as an RStudio Project. You’ll probably also want to open a terminal (Appendix A) within RStudio for some Git work via Tools &gt; Terminal &gt; New Terminal. Make sure you are on the master branch and your “working tree is clean”. git status should show something like: On branch master Your branch is up to date with &#39;origin/master&#39;. nothing to commit, working tree clean BTW I recommend that you never make your own commits to the master branch of a fork. However, if you have already done so, we are going to address your sorry situation below. 7.7.3 List your remotes Let’s inspect the current remotes for your local repo. In the shell (Appendix A): git remote -v Most of you will see output along these lines (let’s call this BEFORE): origin https://github.com/YOU/REPO.git (fetch) origin https://github.com/YOU/REPO.git (push) There is only one remote, named origin, corresponding to your fork on GitHub. This figure depicts a BEFORE scenario: This is sad, because there is no direct connection between OWNER/REPO and your local copy of the repo. The state we want to see is like this (let’s call this AFTER): origin https://github.com/YOU/REPO.git (fetch) origin https://github.com/YOU/REPO.git (push) upstream https://github.com/OWNER/REPO.git (fetch) upstream https://github.com/OWNER/REPO.git (push) Notice the second remote, named upstream, corresponding to the original repo on GitHub. This figure depicts AFTER, the scenario we want to achieve: Sidebar: If you used usethis::create_from_github(\"OWNER/REPO\") for your original “fork and clone”, the upstream should already be set up. In that case, you can skip to the part where we pull from upstream. 7.7.4 Add the upstream remote Let us add OWNER/REPO as the upstream remote. On GitHub, make sure you are signed in and navigate to the original repo, OWNER/REPO. It is easy to get to from your fork, YOU/REPO, via “forked from” links near the top. Use the big green “Clone or download” button to get the URL for OWNER/REPO on your clipboard. Be intentional about whether you copy the HTTPS or SSH URL. 7.7.4.1 Command line Git Use a command like this, but make an intentional choice about using an HTTPS vs SSH URL. git remote add upstream https://github.com/OWNER/REPO.git The nickname upstream can technically be whatever you want. There is a strong tradition of using upstream in this context and, even though I have better ideas, I believe it is best to conform. Every book, blog post, and Stack Overflow thread that you read will use upstream here. Save your psychic energy for other things. 7.7.4.2 RStudio This feels a bit odd, but humor me. Click on “New Branch” in the Git pane. ] This will reveal a button to “Add Remote”. Click it. Enter upstream as the remote name and paste the URL for OWNER/REPO that you got from GitHub. Click “Add”. Decline the opportunity to add a new branch by clicking “Cancel”. 7.7.5 Verify your upstream remote Let’s inspect the current remotes for your local repo AGAIN. In the shell: git remote -v Now you should see something like origin https://github.com/YOU/REPO.git (fetch) origin https://github.com/YOU/REPO.git (push) upstream https://github.com/OWNER/REPO.git (fetch) upstream https://github.com/OWNER/REPO.git (push) Notice the second remote, named upstream, corresponding to the original repo on GitHub. We have gotten to this: 7.7.6 Pull changes from upstream Now we can pull the changes that we don’t have from OWNER/REPO into our local copy. git pull upstream master --ff-only This says: “pull the changes from the remote known as upstream into the master branch of my local repo”. We are being explicit about the remote and the branch in this case, because (as our git remote -v commands reveal), upstream/master is not the default tracking branch for local master. I highly recommend using the --ff-only flag in this case, so that you also say “if I have made my own commits to master, please force me to confront this problem NOW”. Here’s what it looks like if a fast-forward merge isn’t possible: $ git pull upstream master --ff-only From github.com:OWNER/REPO * branch master -&gt; FETCH_HEAD fatal: Not possible to fast-forward, aborting. See Um, what if I did touch master? to get yourself back on the happy path. 7.7.7 Push these changes to origin/master This is, frankly, totally optional and many people who are facile with Git do not bother. If you take my advice to never work in master of a fork, then the state of the master branch in your fork YOU/REPO does not matter. You will never make a pull request from master. If, however, your grasp of all these Git concepts is tenuous at best, it can be helpful to try to keep things simple and orderly and synced up. Feel free to push the newly updated state of local master to your fork YOU/REPO and enjoy the satisfaction of being “caught up” with OWNER/REPO. In the shell: git push Or use the green “Push” button in RStudio. 7.7.8 Um, what if I did touch master? I told you not to! But OK here we are. Let’s imagine this is the state of the original repo OWNER/REPO: ... -- A -- B -- C -- D -- E -- F and this is the state of the master branch in your local copy: ... -- A -- B -- C -- X -- Y -- Z The two histories agree, up to commit or state C, then they diverge. If you want to preserve the work in commits X, Y, and Z, create a new branch right now, with tip at Z, via git checkout -b my-great-innovations (pick your own branch name!). Then checkout master via git checkout master. I now assume you have either preserved the work in X, Y, and Z (with a branch) or have decided to let it go. Do a hard reset of the master branch to C. git reset --hard C You will have to figure out how to convey C in Git-speak. Specify it’s relative to HEAD or provide the SHA. See future link about resets for more support. The instructions above for pulling changes from upstream should now work. Your master branch should reflect the history of OWNER/REPO: ... -- A -- B -- C -- D -- E -- F If you chose to create a branch with your work, you will also have that locally: ... -- A -- B -- C -- D -- E -- F (master) \\ -- X -- Y -- Z (my-great-innovations) If you pushed your alternative history (with commits X, Y, and Z) to your fork YOU/REPO and you like keeping everything synced up, you will also need to force push master via git push --force, but we really really don’t like discussing force pushes in Happy Git. We only do so here, because we are talking about a fork, which is fairly easy to replace if things so sideways. 7.8 Get upstream changes for a fork This workflow is relevant if you have done fork and clone and now you need to pull subsequent changes from the original repo into your copy. Sometimes you set this up right away, when you fork and clone, even though you don’t need it yet. Congratulations, you are planning for the future! It’s also very typical to do this step a few days or months later. Maybe you’re taking an interest in someone else’s work for the second time and you want to make another pull request. Or you just want your copy to reflect their recent work. It is also totally normal to set this up upon first need. Vocabulary: OWNER/REPO refers to the original GitHub repo, owned by OWNER, who is not you. YOU/REPO refers to your copy on GitHub, i.e. your fork. 7.8.1 No, you can’t do this via GitHub You might hope that GitHub could automatically keep your fork YOU/REPO synced up with the original OWNER/REPO. Or that you could do this in the browser interface. Then you could pull those upstream changes into your local repo. But you can’t. There are some tantalizing, janky ways to sort of do parts of this. But they have fatal flaws that make them unsustainable. I believe you really do need to add OWNER/REPO as a second remote on your repo and pull from there. 7.8.2 Initial conditions Get into the repo of interest, i.e. your local copy. For many of you, this means launching it as an RStudio Project. You’ll probably also want to open a terminal (Appendix A) within RStudio for some Git work via Tools &gt; Terminal &gt; New Terminal. Make sure you are on the master branch and your “working tree is clean”. git status should show something like: On branch master Your branch is up to date with &#39;origin/master&#39;. nothing to commit, working tree clean BTW I recommend that you never make your own commits to the master branch of a fork. However, if you have already done so, we are going to address your sorry situation below. 7.8.3 List your remotes Let’s inspect the current remotes for your local repo. In the shell (Appendix A): git remote -v Most of you will see output along these lines (let’s call this BEFORE): origin https://github.com/YOU/REPO.git (fetch) origin https://github.com/YOU/REPO.git (push) There is only one remote, named origin, corresponding to your fork on GitHub. This figure depicts a BEFORE scenario: 7.9 Make a GitHub repo browsable The unreasonable effectiveness of GitHub browsability. One of my favorite aspects of GitHub is the ability to inspect a repository’s files in a browser. Certain practices make browsing more rewarding and can postpone the day when you must create a proper website for a project. Perhaps indefinitely. 7.9.1 Be savvy about your files Keep files in the plainest, web-friendliest form that is compatible with your main goals. Plain text is the very best. GitHub offers special handling for certain types of files: Markdown files, which may be destined for conversion into, e.g., HTML Markdown files named README.md HTML files, often the result of compiling Markdown files Source code, such as .R files Delimited files, such as CSVs and TSVs PNG files 7.9.2 Get over your hang ups re: committing derived products Let’s acknowledge the discomfort some people feel about putting derived products under version control. Specifically, if you’ve got an R Markdown document foo.Rmd, it can be knit() to produce the intermediate product foo.md, which can be converted to the ultimate output foo.html. Which of those files are you “allowed” to put under version control? Source-is-real hardliners will say only foo.Rmd but pragmatists know this can be a serious bummer in real life. Just because I can rebuild everything from scratch, it doesn’t mean I want to. The taboo of keeping derived products under version control originates from compilation of binary executables from source. Software built on a Mac would not work on Windows and so it made sense to keep these binaries out of the holy source code repository. Also, you could assume the people with access to the repository have the full development stack and relish opportunities to use it. None of these arguments really apply to the foo.Rmd --&gt; foo.md --&gt; foo.html workflow. We don’t have to blindly follow traditions from the compilation domain! In fact, looking at the diffs for foo.md or foo-figure-01.png can be extremely informative. This is also true in larger data analytic projects after a make clean; make all operation. By looking at the diffs in the downstream products, you often catch unexpected changes. This can tip you off to changes in the underlying data and/or the behavior of packages you depend on. This chapter explores cool things GitHub can do with various file types, if they happen to end up in your repo. I won’t ask you how they got there. 7.9.3 Markdown You will quickly discover that GitHub renders Markdown files very nicely. By clicking on foo.md, you’ll get a decent preview of foo.html. Yay! You should read GitHub’s own guide on how to leverage automatic Markdown rendering. Exploit this aggressively. Make Markdown your default format for narrative text files and use them liberally to embed notes to yourself and others in a repository hosted on Github. It’s an easy way to get pseudo-webpages inside a project “for free”. You may never even compile these files to HTML explicitly; in many cases, the HTML preview offered by GitHub is all you ever need. 7.9.4 R Markdown What does this mean for R Markdown files? Keep intermediate Markdown. Or only render to Markdown. Commit both foo.Rmd and foo.md, even if you choose to .gitignore the final product, e.g. foo.html or foo.pdf or foo.docx. From September 2014, GitHub renders R Markdown files nicely, like Markdown, and with proper syntax highlighting, which is great. But, of course, the code blocks just sit there un-executed, so my advice about keeping Markdown still holds. If your target output format is not Markdown, you want YAML frontmatter that looks something like this for .Rmd: --- title: &quot;Something fascinating&quot; author: &quot;Jenny Bryan&quot; date: &quot;`r format(Sys.Date())`&quot; output: html_document: keep_md: TRUE --- or like this for .R: #&#39; --- #&#39; title: &quot;Something fascinating&quot; #&#39; author: &quot;Jenny Bryan&quot; #&#39; date: &quot;`r format(Sys.Date())`&quot; #&#39; output: #&#39; html_document: #&#39; keep_md: TRUE #&#39; --- The keep_md: TRUE part says to keep the intermediate Markdown. In RStudio, when editing .Rmd, click on the gear next to “Knit HTML” for YAML authoring help. Since 2016, rmarkdown offers a custom output format for GitHub-flavored markdown, github_document. Read about R Markdown workflows for explicit examples of how to use this. If Markdown is your target output format, your YAML can be even simpler and look like this for .Rmd: --- output: github_document --- or like this for .R: #&#39; --- #&#39; output: github_document #&#39; --- For a quick, stand-alone document that doesn’t fit neatly into a repository or project (yet), make it a Gist. Example: Hadley Wickham’s advice on what you need to do to become a data scientist. Gists can contain multiple files, so you can still provide the R script or R Markdown source and the resulting Markdown, as I’ve done in this write-up of Twitter-sourced tips for cross-tabulation. I’ve collected YAML examples for all the above scenarios in a gist. 7.9.5 README.md You probably already know that GitHub renders README.md at the top-level of your repo as the de facto landing page. This is analogous to what happens when you point a web browser at a directory instead of a specific web page: if there is a file named index.html, that’s what the server will show you by default. On GitHub, files named README.md play exactly this role for directories in your repo. Implication: for any logical group of files or mini project-within-your-project, create a sub-directory in your repository. And then create a README.md file to annotate these files, collect relevant links, etc. Now when you navigate to the sub-directory on GitHub the nicely rendered README.md will simply appear. The GitHub repo that backs the gapminder data package has a README in the data-raw subdirectory that explains exactly how the package data is created. In fact, it is generated programmatically from README.Rmd. Some repositories consist solely of README.md. Examples: Jeff Leek’s write-ups on How to share data with a statistician or Developing R packages. I am becoming a bigger fan of README-only repos than gists because repo issues trigger notifications, whereas comments on gists do not. If you’ve got a directory full of web-friendly figures, such as PNGs, you can use code like this to generate a README.md for a quick DIY gallery, as Karl Broman has done with his FruitSnacks. I did same for all the fantastic O RLY book covers made by The Practical Dev. I have also used this device to share Keynote slides on GitHub (mea culpa!). Export them as PNGs images and throw ’em into a README gallery: slides on file organization and some on file naming. 7.9.6 Finding stuff OK these are pure GitHub tips but if you’ve made it this far, you’re obviously a keener. Press t to activate the file finder whenever you’re in a repo’s file and directory view. AWESOME, especially when there are files tucked into lots of subdirectories. Press y to get a permanent link when you’re viewing a specific file. Watch what changes in the URL. This is important if you are about to link to a file or to specific lines. Otherwise your links will break easily in the future. If the file is deleted or renamed or if lines get inserted or deleted, your links will no longer point to what you intended. Use y to get links that include a specific commit in the URL. 7.9.7 HTML If you have an HTML file in a GitHub repository, simply visiting the file shows the raw HTML. Here’s a nice ugly example: https://github.com/STAT545-UBC/STAT545-UBC.github.io/blob/master/bit003_api-key-env-var.html No one wants to look at that. You can provide this URL to rawgit.com to serve this HTML more properly and get a decent preview. You can form two different types of URLs with rawgit.com: For sharing low-traffic, temporary examples or demos with small numbers of people, do this: https://rawgit.com/STAT545-UBC/STAT545-UBC.github.io/master/bit003_api-key-env-var.html Basically: replace https://github.com/ with https://rawgit.com/ For use on production websites with any amount of traffic, do this: https://cdn.rawgit.com/STAT545-UBC/STAT545-UBC.github.io/master/bit003_api-key-env-var.html Basically: replace https://github.com/ with https://cdn.rawgit.com/ 2018-10-09 update: RawGit announced that it is in a sunset phase and will soon shut down. They recommended: jsDelivr, GitHub Pages, CodeSandbox, and unpkg as alternatives. This sort of enhanced link might be one of the useful things to put in a README.md or other Markdown file in the repo. You may also want to check out this Chrome extension or GitHub &amp; BitBucket HTML Preview, though recently I’ve more success with rawgit.com. (Neither work with private GitHub repos, which is all the more reason to keep intermediate markdown files for HTML, as described above.) Sometimes including HTML files will cause GitHub to think that your R repository is HTML. Besides being slightly annoying, this can make it difficult for people to find your work if they are searching specifically for R repos. You can exclude these files or directories from GitHub’s language statistics by adding a .gitattributes file that marks them as ‘documentation’ rather than code. See an example here. 7.9.8 Source code You will notice that GitHub does automatic syntax highlighting for source code. For example, notice the coloring of this R script. The file’s extension is the primary determinant for if/how syntax highlighting will be applied. You can see information on recognized languages, the default extensions and more at github/linguist. You should be doing it anyway, but let this be another reason to follow convention in your use of file extensions. Note you can click on “Raw” in this context as well, to get just the plain text and nothing but the plain text. 7.9.9 Delimited files GitHub will nicely render tabular data in the form of .csv (comma-separated) and .tsv (tab-separated) files. You can read more in the blog post announcing this feature in August 2013 or in this GitHub help page. Advice: take advantage of this! If something in your repo can be naturally stored as delimited data, by all means, do so. Make the comma or tab your default delimiter and use the file suffixes GitHub is expecting. I have noticed that GitHub is more easily confused than R about things like quoting, so always inspect the GitHub-rendered .csv or .tsv file in the browser. You may need to do light cleaning to get the automagic rendering to work properly. Think of it as yet another way to learn about imperfections in your data. Here’s an example of a tab delimited file on GitHub: lotr_clean.tsv, originally found here (nope, IBM shut down manyeyes July 2015). Note you can click on “Raw” in this context as well, to get just the plain text and nothing but the plain text. 7.9.10 PNGs PNG is the “no brainer” format in which to store figures for the web. But many of us like a vector-based format, such as PDF, for general purpose figures. Bottom line: PNGs will drive you less crazy than PDFs on GitHub. To reduce the aggravation around viewing figures in the browser, make sure to have a PNG version in the repo. Examples: This PNG figure just shows up in the browser A different figure stored as PDF produces the dreaded, annoying “View Raw” speed bump. You’ll have to click through and, on my OS + browser, wait for the PDF to appear in an external PDF viewer. 2015-06-19 update: since I first wrote this GitHub has elevated its treament of PDFs so YAY. It’s slow but it works. Hopefully we are moving towards a world where you can have “web friendly” and “vector” at the same time, without undue headaches. As of October 2014, GitHub provides enhanced viewing and diffing of SVGs. So don’t read this advice as discouraging SVGs. Make them! But consider keeping a PNG around as emergency back up for now. 7.9.11 Other document formats You may also have a document you want others to be able to browse and interact with, but it is not in the markdown format. Fortunately, the open-source Pandoc program, written by John MacFarlane, allows you to convert a range of formats into markdown, including the widely used .docx format. When you click the Knit button in RStudio it is actually Pandoc which performs the final conversion to HTML or Microsoft Word (.docx) formats. If you are willing to use the command-line, you can perform the opposite conversion (eg .docx to .md), commonly retaining features such as headings, tables, equations and even figures. As some boilerplate, running in Windows PowerShell pandoc --extract-media .\\media -f docx .\\example.docx -t markdown_github -o example_image.md converts a word document called example.docx to markdown, and extracts the images into a directory which corresponds to a filepath in the newly created example.md document. A full list of supported formats and example code for conversions are available at https://pandoc.org/. You can also perform simple conversions to GitHub-flavored markdown from different markdown flavours (Pandoc supports markdown_mmd, markdown_php_extra and markdown_strict) from within RStudio. To do so you need to rename the file by changing the extension (eg from foo.md to foo.Rmd), then open the renamed file in RStudio and add the following text to the top of the document. --- output: github_document --- You can then click on “Knit” then “Knit to github document” to perform the conversion. See Output format for more details of controlling output formats with the YAML frontmatter. 7.9.12 Linking to a ZIP archive of your repo The browsability of GitHub makes your work accessible to people who care about your content but who don’t (yet) use Git themselves. What if such a person wants all the files? Yes, there is a clickable “Download ZIP” button offered by GitHub. But what if you want a link to include in an email or other document? If you add /archive/master.zip to the end of the URL for your repo, you construct a link that will download a ZIP archive of your repository. Click here to try this out on a very small repo: https://github.com/jennybc/lotr/archive/master.zip Go look in your downloads folder! 7.10 Links and embedded figures To link to another page in your repo, just use a relative link: [admin](courseAdmin/) will link to the courseAdmin/ directory inside the current directory. [admin](/courseAdmin/) will link to the top-level courseAdmin/ directory from any where in the repo The same idea also works for images. ![](image.png) will include image.png located in the current directory "],["shell.html", "A The shell A.1 What is the shell? A.2 Starting the shell A.3 Windows is special … and not in a good way A.4 Basic shell commands", " A The shell Even if you do most of your Git operations via a client, such as RStudio or GitKraken, you must sometimes work in the shell. As you get more comfortable with Git, you might prefer to do more and more via the command line. You might also need to use Git or file system operations on a server that lacks your usual Git client. For all these reasons, it is a good idea to learn your way around the shell. Here’s a typical look for a shell. You’ll see a simple blinking cursor, waiting for input: A.1 What is the shell? The shell is a program on your computer whose job is to run other programs. Pseudo-synonyms are “terminal”, “command line”, and “console”. There’s a whole StackExchange thread on the differences ( What is the difference between Terminal, Console, Shell, and Command Line? ), but I don’t find it to be terribly enlightening. Your mileage may vary. Many programmers spend lots of time in a shell, as opposed to in GUIs, because it is very fast, concise, and ubiquitous in their relevant computing environments. This is how all work was done before we got the mouse and GUIs. The most common shell is bash and it gets thrown around as a proxy for “shell” sometimes, just like “Coke” and “Kleenex” are proxies for cola and tissues. A.2 Starting the shell A.2.1 From within RStudio You can launch a shell from RStudio. This is often handy, because RStudio makes every effort to put you in a sane working directory, i.e. in the current project. There are two ways: Tools &gt; Terminal launches a shell within RStudio, graphically and process-wise. I believe this is usually what you want. Tools &gt; Shell … launches a shell external to RStudio. A.2.2 Outside of RStudio A.2.2.1 macOS The shell is often called the “terminal” on macOS, by which people mean Terminal.app. One way to launch is via Spotlight Search. Type Command + space and start typing “terminal”. This process will something like so: Terminal.app is typically located at /Applications/Utilities/Terminal.app. Opening Terminal.app brings you to a bash shell opened to your home directory ~/, which is shorthand for /Users/YOURUSERNAME. You should see something like this: If you have administrative rights on your computer, prefacing any command with sudo will allow you to run the command as an administrator. Expect to be challenged for your password. If you need to change administrative privileges or your password, see this article from Apple. A.2.2.2 Windows We defer this until the next section, due to the more complex shell situation on Windows. A.3 Windows is special … and not in a good way Windows is not the ideal platform for scientific computing and software development. A lot of the functionality is going to feel janky and strapped on. Because it is. There are no fewer than 4 possible shells you can end up in. Unless you know better, you almost certainly want to be in a Git Bash shell. Windows users will want to understand the different types of shell, how to launch them, and how to tell which one you’re in. A.3.1 Git Bash TL;DR how to tell if you’re in a Git Bash shell? Do this: $ echo $SHELL /usr/bin/bash Git Bash is a bash shell that ships with Git for Windows, which is the Happy Git way to install Git on Windows. Therefore, you will not have Git Bash on your system until you install Git for Windows. Git Bash is always the Windows shell we are targeting in our instructions. RStudio should automatically detect the presence of Git Bash. You can inspect and influence this directly via Tools &gt; Global Options &gt; Terminal. Unless you have good reason to do otherwise, you want to see “Git Bash” in the “New terminals open with …” dropdown menu. Troubleshooting tips: Restart RStudio. You need to restart all instances of RStudio after installing Git for Windows (+ Git Bash), in order for RStudio to auto-detect Git Bash. Update RStudio. The shell handling in RStudio has improved dramatically over time, so older versions might not behave as described here. A.3.1.1 Accessing Git Bash outside of RStudio Sometimes you want to run Git Bash outside of RStudio. Here’s the easiest way: click the “Git” menu in the Windows menu and select “Git Bash”. A Git Bash shell running outside of RStudio looks something like this: Notice MSYS in the title bar. You might also see MINGW64. Sometimes you need to run Git Bash as administrator, e.g. to run with higher privileges. Easiest way: click the “Git” menu in the Windows menu and right-click on “Git Bash”. This reveals a submenu. Select “more” and then “Run as administrator”. A.3.2 Command prompt TL;DR how to tell if you’re in Command Prompt? Do this: C:\\Users\\jenny&gt;echo %COMSPEC% C:\\WINDOWS\\system32\\cmd.exe This is the native Windows command line interpreter. It’s rarely what you want, especially for the work described in this document. A Command Prompt session running outside of RStudio looks something like this: Notice the cmd.exe in the title bar, although it is not always present. You might also see “Command Prompt”. If you get an error message such as 'pwd' is not recognized as an internal or external command, operable program or batch file. from a shell command, that suggests you have somehow launched into cmd.exe when you did not mean to. A.3.3 PowerShell TL;DR how to tell if you’re in PowerShell? Do this: PS C:\\Users\\jenny&gt; Get-ChildItem Env:ComSpec Name Value ---- ----- ComSpec C:\\WINDOWS\\system32\\cmd.exe PowerShell is yet another Windows shell, a more modern successor to Command Prompt. It’s also rarely what you want, especially for the work described in Happy Git. A PowerShell session running outside of RStudio looks something like this: Notice the powershell.exe in the title bar. A.3.4 Bash via Windows Services for Linux TL;DR how to tell if you’re in Bash via WSL? Do this: $ echo $SHELL /bin/bash In 2016, Microsoft launched the Windows Subsystem for Linux (WSL), “a new Windows 10 feature that enables you to run native Linux command-line tools directly on Windows”. Overall, this is a fantastic development. However, at the time of writing (January 2019), you will only have this if you’re running Windows 10 64-bit and have chosen to install the optional WSL system component. Therefore, I expect only keeners to have this and, in that case, you probably don’t need this chapter. A WSL bash shell running outside of RStudio looks something like this: FYI Microsoft also refers to WSL as Bash on Ubuntu on Windows. A.3.4.1 Windows bottom line When in doubt, you probably want to be in a Git Bash shell. A.4 Basic shell commands The most basic commands are listed below: pwd (print working directory). Shows directory or “folder” you are currently operating in. This is not necessarily the same as the R working directory you get from getwd(). ls (list files). Shows the files in the current working directory. This is equivalent to looking at the files in your Finder/Explorer/File Manager. Use ls -a to also list hidden files, such as .Rhistory and .git. cd (change directory). Allows you to navigate through your directories by changing the shell’s working directory. You can navigate like so: go to subdirectory foo of current working directory: cd foo go to parent of current working directory: cd .. go to your “home” directory: cd ~ or simply cd go to directory using absolute path, works regardless of your current working directory: cd /home/my_username/Desktop. Windows uses a slightly different syntax with the slashes between the folder names reversed, \\, e.g. cd C:\\Users\\MY_USERNAME\\Desktop. Pro tip 1: Dragging and dropping a file or folder into the terminal window will paste the absolute path into the window. Pro tip 2: Use the tab key to autocomplete unambiguous directory and file names. Hit tab twice to see all ambiguous options. Use arrow-up and arrow-down to repeat previous commands. Or search for previous commands with CTRL + r. A few Git commands: git status is the most used git command and informs you of your current branch, any changes or untracked files, and whether you are in sync with your remotes. git remote -v lists all remotes. Very useful for making sure git knows about your remote and that the remote address is correct. git remote add origin GITHUB_URL adds the remote GITHUB_URL with nickname origin. git remote set-url origin GITHUB_URL changes the remote url of origin to GITHUB_URL. This way you can fix typos in the remote url. Feel free to suggest other commands that deserve listing in a GitHub issue. "],["burn.html", "B Burn it all down", " B Burn it all down This is a highly inelegant, but effective technique for disaster recovery. Basic idea: Commit early and often. Push to a remote, like GitHub, often. The state of things on GitHub is your new “worst case scenario”. If you really screw things up locally, copy all the files (or the ones that have changed) to a safe place. Usually your files are JUST FINE. But it is easy to goof up the Git infrastructure when you’re new at this. And it can be hard to get that straightened out on your own. Rename the existing local repo as a temporary measure, i.e. before you do something radical, like delete it. Clone the repo from GitHub to your local machine. You are back to a happy state. Copy all relevant files back over from your safe space. The ones whose updated state you need to commit. Stage and commit. Push. Carry on with your life. Practice this before you need it, so you see how it works. "],["troubleshooting.html", "C RStudio, Git, GitHub Hell C.1 I think I have installed Git but damn if I can find it C.2 RStudio Git pane disappears on Mac OS C.3 Dysfunctional PATH C.4 Push/Pull buttons greyed out in RStudio C.5 I have no idea if my local repo and my remote repo are connected. C.6 Push fail at the RStudio level C.7 Push rejected, i.e. fail at the Git/GitHub level C.8 RStudio is not making certain files available for staging/committing C.9 I hear you have some Git repo inside your Git repo", " C RStudio, Git, GitHub Hell Problems we have seen and possible solutions. If you experience some new problem and, especially, find the corresponding solution, we’d love to hear from you! C.1 I think I have installed Git but damn if I can find it When you install Git, try to control or record where it is being installed! Make a mental or physical note of these things. You may be able to find Git after the fact with these commands in the shell (Appendix A): which git (Mac, Linux, or anything running a bash shell) where git (Windows, when not in a bash shell) It is not entirely crazy to just re-install Git, using a method that leaves it in a more conventional location, and to pay very close attention to where it’s being installed. Live and learn. C.2 RStudio Git pane disappears on Mac OS Sometimes the RStudio Git pane disappears on a system where it was previously working. This usually happens to people who installed Git by installing the Xcode command line tools. It is usually a sign that you need to re-agree to the Xcode license agreement. This is necessary after a Mac OS upgrade, re-installing Xcode, or even quiet Xcode upgrades that happen in normal system maintenance. In the shell, you could execute git status and you might see a message along these lines: Agreeing to the Xcode/iOS license requires admin privileges, please run “sudo xcodebuild -license” and then retry this command. If you get such clear instructions, by all means do what it says, i.e. run sudo xcodebuild -license, to re-agree to the license. In any case, you need to tickle the Xcode command line tools to prompt you for whatever it needs. Here are other commands that, depending on the situation, might trigger the necessary prompts: xcode-select --install or git config --global --list Then restart RStudio. C.3 Dysfunctional PATH I’m pretty sure that most cases of RStudio not automatically detecting the Git executable stem from problems with PATH. This is the set of directories where your computer will look for executables, such as Git (today) or make (later in this course). Certain methods of Git installation, especially on Windows and/or older OSes, have a higher tendency to put Git in an unconventional location or to fail to add the relevant directory to PATH. How to see your PATH? In the shell: echo $PATH Take a good hard look at this. See the point above about finding your Git executable or re-installing it while you are wide awake. Is the host directory in your PATH? No? Fix that. Go here for instructions on what to put in your .bash_profile in order to add a directory to PATH. C.4 Push/Pull buttons greyed out in RStudio Are you sure your local repository is associated with a remote repository, e.g. a GitHub repo? In a shell with working directory set to the local Git repo, enter this command: jenny@2015-mbp myrepo $ git remote -v origin https://github.com/jennybc/myrepo (fetch) origin https://github.com/jennybc/myrepo (push) We want to see that fetch and push are set to remote URLs that point to the remote repo. Note also that the GitHub repo is a remote named origin, as far as your local repo is concerned. This is typical and, though I think github is a vastly superior name, origin is such a strong convention that I follow it. If you discover you still need to set a remote, get the HTTPS or SSH URL, as appropriate, for your GitHub repo. This is easy to get onto your clipboard from the repo’s GitHub page. Do this in the shell: git remote add origin https://github.com/jennybc/myrepo.git Download all the files from the online GitHub repository and deal with any conflicts. git pull origin master Call git remote -v again. Once you can prove that your GitHub remote is set properly, you can move on to the next step. Are you sure the current branch is tracking a branch on the remote? In that same shell, in your repo, do this: jenny@2015-mbp myrepo $ git branch -vv * master b8e03e3 [origin/master] line added locally The above shows successful confirmation that the local master branch is tracking origin/master, i.e. the master branch on GitHub. If you don’t see the [origin/master] bit, that is a problem. By the way, git branch -r is another handy way to examine your remote-tracking branches. (If you’re working with a branch other than master, adjust everything accordingly.) When connecting a local repo to a new GitHub repo, a lot of people remember to add the GitHub remote, but forget to also cement this tracking relationship for any relevant branches. If you discover your local master branch is not yet tracking master on GitHub, fix that like so: git push --set-upstream origin master This is equivalent to git push -u origin master but conveys more about what you are doing. Call git branch -vv or git branch -r again to confirm that the master branch on GitHub is the upstream or tracking branch for the local master branch. C.5 I have no idea if my local repo and my remote repo are connected. See the above section on “Push/Pull buttons greyed out in RStudio.” C.6 Push fail at the RStudio level Do you get this error in RStudio? error: unable to read askpass response from &#39;rpostback-askpass&#39; Open the shell: Tools &gt; Shell. git push -u origin master C.7 Push rejected, i.e. fail at the Git/GitHub level You might have changes on the remote AND on your local repo. Just because you don’t remember making any edits in the browser doesn’t mean you didn’t. Humor me. Pull first. Resolve any conflicts. Then try your push again. C.8 RStudio is not making certain files available for staging/committing Do you have a space in your directory or file names? A space in a file name is a space in your soul. Get rid of it. Is your Git repo / RStudio Project inside a folder that … eventually rolls up to Google Drive, DropBox, Microsoft OneDrive, or a network drive? If yes, I recommend you move the repo / Project into a plain old directory that lives directly on your computer and that is not managed by, e.g., Google Drive. If you cannot deal with the two root causes identified above, then it is possible that a more powerful Git client (chapter 2.5) will be able to cope with these situations. But I make no promises. You should also try Git operations from the command line. C.9 I hear you have some Git repo inside your Git repo Do not create a Git repository inside another Git repository. Just don’t. If you have a genuine need for this, which is really rare, the proper way to do it is via submodules. "],["credential-caching.html", "D Cache credentials for HTTPS D.1 You should get a personal access token (PAT) D.2 Store your credential D.3 Activating a Git credential helper", " D Cache credentials for HTTPS If you plan to push/pull using HTTPS, you want to cache your credentials (e.g. password), so you don’t need to enter them over and over again. Alternatively, you could set up SSH keys (chapter ??). I suggest you set up one of these methods of authentication on each computer you want to connect to GitHub from. I find HTTPS easier to get working quickly and strongly recommend it when you first start working with Git/GitHub. HTTPS is what GitHub recommends, presumably for exactly the same reasons. I started with HTTPS, preferred SSH for a while, and have returned to HTTPS. Either is fine, you can change your mind later, and you can use HTTPS on one machine and SSH on another. Remember: the transport protocol is controlled by the URL you use for remote repo access. HTTPS remotes look like https://github.com/&lt;OWNER&gt;/&lt;REPO&gt;.git. SSH remotes look like git@github.com:&lt;OWNER&gt;/&lt;REPO&gt;.git. D.1 You should get a personal access token (PAT) D.1.1 Why a PAT? Password-based authentication for Git is deprecated, i.e. you really should not be sending your username and password every time you push or pull. Here, I’m referring to the username and password you would use to login to GitHub in the browser. What should you do instead? Get a personal access token (PAT) and use that as your credential for HTTPS operations. (The PAT will actually be sent as the password and the username is somewhat artificial, consulted only for credential lookup.) If you turn on two-factor authentication (a.k.a. “2FA”) for GitHub and you use HTTPS, you absolutely must send a personal access token. And, really, it’s a good idea for everyone to turn on 2FA and for everyone who uses HTTPS to use a PAT. The final selling point is that once you configure a PAT, several R packages, including usethis and gh, will be able to work with the GitHub API on your behalf, automagically. Therefore, a properly configured PAT means all of this will work seamlessly: Remote HTTPS operations via command line Git and, therefore, via RStudio Remote HTTPS operations via the gert R package and, therefore, usethis GitHub API operations via the gh R package and, therefore, usethis D.1.2 How to get a PAT? GitHub offers instructions for creating a personal access token. The usethis package has a helper function that takes you to the web form to create a PAT, with the added benefit that it pre-selects the recommended scopes: usethis::create_github_token() Once you are happy with the selected scopes, click “Generate token”. As the page says, you must store this token somewhere, because you’ll never be able to see it again, once you leave that page or close the window. D.1.3 How to manage a PAT? Treat this PAT like a password! If you use a password management app, such as 1Password or LastPass (which you should), it is highly recommended to add this PAT to your entry for GitHub. Below, we will add your PAT to the Git credential store as a semi-persistent convenience, sort of like “remember me” on a website. But, just like logging into websites, it is entirely possible that your PAT will somehow be forgotten from the credential store and you will need to re-enter it. If you goof this up, i.e. generate a PAT but fail to capture it on your system, you’ll have to generate another one. This is not the end of the world, but you should delete the “lost” PAT on GitHub. If you aren’t disciplined about labelling PATs and deleting lost PATs, you will find yourself in an unsettling situation where you can’t be sure which PAT(s) are in use. When logged into your GitHub account, you can manage your PATs here: https://github.com/settings/tokens Do not ever hard-wire your PAT into your code! A PAT should always be retrieved implicitly, for example, from the Git credential store or from an environment variable. At this point, I assume you’ve generated a PAT and have it available, either: In a secure, long-term system for storing secrets, like 1Password or LastPass (recommended) For the next few minutes, e.g. in a browser window or on the clipboard D.2 Store your credential There are many ways to get your credential into the Git store. You need to trigger a prompt for your credential and usually it will be stored for next time. If your credential doesn’t seem to be stored and re-discovered, see the last section. If something has been stored and is being re-discovered, but you’re not 100% sure it’s what you want (e.g. username and password vs. PAT), we give some pointers below. Ways to access the credential store, in order of relevance: Call an R function to store (or update) your credentials Organic Git use, e.g. via the command line or even RStudio (clunky) Make an explicit call to the Git credential manager (for keeners only) Go into your OS-level credential store (for keeners only) D.2.1 Call an R function to store your credentials As of November 2020, there are two R packages for accessing the Git credential store: gitcreds credentials It is likely that these packages will eventually combine into one and, even now, they are largely interoperable. You don’t need to follow the instructions for both packages – pick one! D.2.1.1 gitcreds package If you don’t have gitcreds installed, install via install.packages(\"gitcreds\"). Then call gitcreds_set(): library(gitcreds) gitcreds_set() gitcreds::gitcreds_set() is a very handy function, since it reports any current credential, allows you to see it, allows you to keep or replace an existing credential, and can also store a credential for the first time. Respond to the prompt with your personal access token (PAT). You can check that you’ve stored a credential with gitcreds_get(): gitcreds_get() #&gt; &lt;gitcreds&gt; #&gt; protocol: https #&gt; host : github.com #&gt; username: PersonalAccessToken #&gt; password: &lt;-- hidden --&gt; D.2.1.2 credentials package If you don’t have credentials installed, install via install.packages(\"credentials\"). Then call set_github_pat(): library(credentials) set_github_pat() Respond to the prompt with your personal access token (PAT). If successful, your initial (and subsequent) calls will look like this: set_github_pat() #&gt; If prompted for GitHub credentials, enter your PAT in the password field #&gt; Using GITHUB_PAT from Jennifer (Jenny) Bryan (credential helper: osxkeychain) Other functions are available if you need more control, such as credentials::git_credential_forget() for clearing a credential. D.2.2 Store credentials through organic Git use Before gitcreds and credentials existed (see above), we had to store the PAT through organic Git use. We still show this method, but we now recommend using the approaches above, because they are much more direct. Pre-requisite: You need a functioning test Git repository. One that exists locally and remotely on GitHub, with the local repo tracking the remote. If you have just verified that you can interact with GitHub (chapter 3.1) from your local computer, that test repo will be perfect. If you have just verified that you can work with GitHub from RStudio (chapter 3.2), that test repo will also be perfect. You may proceed when You have a test repo. You know where it lives on your local computer. Example: /home/jenny/tmp/myrepo You know where it lives on GitHub. Example: https://github.com/jennybc/myrepo You know the GitHub repo is setup as a remote. In a shell (Appendix A) working directory set to the local Git repo, enter: git remote -v Output like this confirms that fetch and push are set to remote URLs that point to your GitHub repo: origin https://github.com/jennybc/myrepo (fetch) origin https://github.com/jennybc/myrepo (push) Now enter: git branch -vv Here we confirm that the local master branch is tracking your GitHub master branch (origin/master). Gibberish? Just check that your output looks similar to mine: master b8e03e3 [origin/master] line added locally Trigger a username / password challenge Change a file in your local repo and commit it. Do that however you wish. Here are shell commands that will work: echo &quot;adding a line&quot; &gt;&gt; README.md git add -A git commit -m &quot;A commit from my local computer&quot; Now push! git push -u origin master You should be asked for your username and password. If you’ve taken our advice to get a PAT, provide your PAT as the password. Hopefully, this credential will be stored. Now push AGAIN. git push You should NOT be asked for your username and password, instead you should see Everything up-to-date. Rejoice and close the shell. D.2.3 Access the Git credential manager directly This is not a recommended interface for regular Git users. It is what the gitcreds and credentials packages and command line Git do on your behalf, when they need a credential. But for completeness, let it be known that, behind the scenes, there is the git credential &lt;fill|approve|reject&gt; command. For keeners, that documentation can shed some light on how credentials are stored and looked up. D.2.4 Access the OS-level keychain or wallet On Windows, your Git credentials are probably being stored via Credential Manager. On macOS, your Git credentials are probably being stored in the Keychain. So if you really want to poke around directly to explore or clean out your GitHub credentials, launch Credential Manager (Windows) or Keychain Access (macOS) and search for “github.com”. D.3 Activating a Git credential helper D.3.1 You might not need to do anything! As of October 2020, if you install Git using the methods recommended here in Happy Git, it is likely that Git is already configured to use a credential helper, backed by a proper credential store provided by your operating system. Of course, you will have to provide your credential at least once, but most users do not need to do anything special to arrange for their credentials to be stored and retrieved later. Specifically, if you are on macOS or Windows, don’t do anything described here until you have actual proof that it’s necessary, i.e. until you have experienced repeated challenges for your credentials when using HTTPS. D.3.2 Windows In my most recent experiments, Git for Windows is configured to store credentials via the Credential Manager. Here’s a command to reveal the configuration and the output I see in a fresh installation of Git for Windows: $ git config --show-origin --get credential.helper file:C:/Program Files/Git/mingw64/etc/gitconfig manager In the unlikely event that you need to activate a credential helper, GitHub’s instructions are the best bet, in terms of being current: Caching your GitHub credentials in Git D.3.3 macOS I have not needed to explicitly activate a credential helper on macOS in a long while. Here’s a command to reveal the current credential helper and the output I see (October 2020, macOS 10.15.6, Git 2.24.3): $ git config --show-origin --get credential.helper file:/Users/jenny/.gitconfig osxkeychain I expect most users to see the osxkeychain helper, configured either at the system or user level. In the unlikely event that you need to activate a credential helper, GitHub’s instructions are the best bet, in terms of being current: Caching your GitHub credentials in Git "],["github-pat.html", "E GitHub Personal Access Tokens E.1 GitHub API E.2 How do you authenticate yourself? E.3 Step-by-step E.4 A note about security E.5 Why .Renviron instead of bash config?", " E GitHub Personal Access Tokens If you Git push or pull via the command line, you can avoid the constant authentication challenge by caching your username and password for HTTPS access or by setting up SSH keys. This includes any Git operations done by RStudio on your behalf. But for some operations you must call the GitHub API (Application Programming Interface). And this requires that you authenticate yourself in a different way. Figure E.1: Ways to authenticate to GitHub’s git server and API E.1 GitHub API The first reason most people need GitHub API access is because they want to use the devtools package. It is popular for the devtools::install_github() function to install directly from GitHub. This is in contrast to installing a package from CRAN via install.packages(). Why install from GitHub instead of CRAN? The package is developed on GitHub and you prefer the development version because it has some features or bug fixes not yet on CRAN. You contribute to or use R packages that are in private repositories on GitHub (or GitHub Enterprise). CRAN is not an option. You want to use helper functions from usethis to manage your GitHub projects, including: usethis::create_from_github(fork = TRUE) to fork and clone a GitHub repository. The usethis::pr_*() family of functions (pr_init(), pr_fetch(), pr_pull(), pr_push(), etc.) to create, update, and locally review pull requests. Other reasons to call the GitHub API include doing almost anything you might do in the browser, especially if you need to do it on a grand scale, i.e., create repositories or users or fetch data. I recommend the gh package for this. Which you must install from GitHub! E.2 How do you authenticate yourself? With access via API, what plays the role of the HTTPS username/password or SSH keys? For the GitHub API, we use a personal access token (PAT), which is a convention followed by many other APIs. You will need to: Obtain a PAT. This is done in the browser or with usethis::browse_github_pat(). Store it so packages like devtools can find it and use it on your behalf. The path of least resistance is to define it in your .Renviron file as the environment variable named GITHUB_PAT. E.3 Step-by-step E.3.1 Create a PAT The easiest way to create a GitHub PAT is with usethis::browse_github_pat(). You will be sent to the form to create a PAT, with reasonable default scopes pre-populated. Alternatively, you can create a PAT by logging in to your GitHub account. Go to https://github.com/settings/tokens. “Generate new token”. Give it a nickname that reminds you of the intended purpose, e.g., “devtools”. Pick scopes that confer the privileges you need. When in doubt, check the repo scope, which is required for typical devtools operations. There used to be a set of default scopes, but that no longer appears to be true. After you click “Generate token”, the token will be displayed. It’s a string of 40 random letters and digits. This is the last time you will see it SO COPY IT TO THE CLIPBOARD. Leave this window open until you’re done. If you somehow goof this up, just generate a new one and try again. E.3.2 Add your PAT to .Renviron Put your PAT in your .Renviron file. Have a line that looks like this: GITHUB_PAT=8c70fd8419398999c9ac5bacf3192882193cadf2 but with your PAT instead of mine. Don’t worry, I’ve revoked this one! .Renviron is a hidden file that lives in your home directory. Not sure where that is? The easiest way to find and edit .Renviron is with a function from the usethis package. In R, do: usethis::edit_r_environ() Your .Renviron file should pop up in your editor. Add your GITHUB_PAT as above, save and close it. Put a line break at the end! If you’re using an editor that shows line numbers, there should be two lines, where the second one is empty. If questioned, YES you do want to use a filename that begins with a dot .. Note that, by default, most dotfiles are hidden in the RStudio file browser, but .Renviron should always be visible. Restart R (Session &gt; Restart R in the RStudio menu bar), as environment variables are loaded from .Renviron only at the start of an R session. Check that the PAT is now available like so: usethis::git_sitrep() You should see the following line in the output: * Personal access token: &#39;&lt;found in env var&gt;&#39; Now commands you run from the devtools package, which consults GITHUB_PAT by default, will be able to access private GitHub repositories to which you have access, and you can install them with devtools::install_github('username/reponame'). E.4 A note about security Many R packages that access web services, such as those maintained by rOpenSci, give the option of storing API “tokens” or “keys” as environment variables in your .Renviron file. These tokens and this file, should never be committed to GitHub, stored in Dropbox, or on any other online service. They should not appear in your code or code comments. This is one reason why this file is stored outside your project folder. These tokens can be used to access your accounts and wreak all kinds of havoc. If you mistakenly share your tokens, log into the relevant site via the browser, revoke the compromised token, and generate a new one. E.5 Why .Renviron instead of bash config? FAQ: Why define this environment variable via .Renviron instead of in .bash_profile or .bashrc?* Because there are many combinations of OS and ways of running R where the .Renviron approach “just works” and the bash stuff does not. When R is a child process of, say, Emacs or RStudio, you can’t always count on environment variables being passed to R. Put them in an R-specific start-up file and save yourself some grief. "],["resources.html", "F Resources", " F Resources We practice what we preach! This site is created with Git and R markdown, using the bookdown package. Go ahead and peek behind the scenes. Long-term, you should understand more about what you are doing. Rote clicking in RStudio may be a short-term survival method but won’t work for long. trygit is to (command line) Git as swirl is to R. Learn by doing, in small bites. The book Pro Git is fantastic and comprehensive. Git in Practice by Mike McQuaid is an more approachable book, probably better than Pro Git for most people starting out. Ancillary materials on GitHub. Git for Humans is a great set of slides by Alice Bartlett, originally delivered in 2016 at UX Brighton. GitHub’s own training materials may be helpful. They also point to many other resources Find a powerful Git client (chapter 2.5) if you’d like to minimize your usage of Git from the command line. Hadley Wickham’s book R Packages has an excellent chapter on the use of Git, GitHub, and RStudio in R package development. He covers more advanced usage, such as commit best practices, issues, branching, and pull requests. Ten Simple Rules for Taking Advantage of Git and GitHub http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004947 RStudio’s guide Version Control with Git and SVN The book Team Geek has insightful advice for the human and collaborative aspects of version control. It proposes Git strategies suited to different characteristics of teams. "],["references.html", "G References", " G References "]]
